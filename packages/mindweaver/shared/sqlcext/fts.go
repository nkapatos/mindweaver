// Package sqlcext provides extensions to sqlc for features it cannot generate.
//
// HAND-WRITTEN FTS5 QUERIES
// This package contains ONLY FTS5-specific queries that sqlc cannot generate
// due to its limited support for SQLite FTS5 virtual tables.
//
// All non-FTS queries should be generated by sqlc from SQL files.
//
// SECURITY: All queries use parameterized statements with ? placeholders.
// DO NOT concatenate user input into SQL strings.
package sqlcext

import (
	"context"
	"database/sql"
	"fmt"
	"time"
)

// DB represents a database connection that can execute queries.
// This interface allows the FTS querier to work with *sql.DB, *sql.Tx, or sqlc.DBTX.
type DB interface {
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

// FTSQuerier provides type-safe FTS5 full-text search operations.
// It can be configured for different table schemas via FTSConfig.
type FTSQuerier struct {
	db     DB
	config FTSConfig
	// Precomputed query strings for performance
	searchQuery        string
	searchSnippetQuery string
	countQuery         string
}

// NewFTSQuerier creates a new FTS querier with the given configuration.
//
// Example for Mind notes:
//
//	config := sqlcext.FTSConfig{
//	    ContentTable: "notes",
//	    FTSTable: "notes_fts",
//	    IDColumn: "id",
//	    ContentRowID: "id",
//	}
//	querier := sqlcext.NewFTSQuerier(db, config)
//
// Example for Brain assistant notes:
//
//	config := sqlcext.FTSConfig{
//	    ContentTable: "assistant_notes",
//	    FTSTable: "assistant_notes_fts",
//	    IDColumn: "id",
//	    ContentRowID: "id",
//	}
//	querier := sqlcext.NewFTSQuerier(db, config)
func NewFTSQuerier(db DB, config FTSConfig) *FTSQuerier {
	// Validate config
	if config.IDColumn == "" {
		config.IDColumn = "id"
	}
	if config.ContentRowID == "" {
		config.ContentRowID = "id"
	}

	q := &FTSQuerier{
		db:     db,
		config: config,
	}

	// Precompute query strings
	q.searchQuery = q.buildSearchQuery(false)
	q.searchSnippetQuery = q.buildSearchQuery(true)
	q.countQuery = q.buildCountQuery()

	return q
}

// buildSearchQuery constructs the FTS search query string.
// If withSnippet is true, returns highlighted snippets instead of full body.
func (q *FTSQuerier) buildSearchQuery(withSnippet bool) string {
	bodyColumn := "ct.body"
	if withSnippet {
		// FTS5 snippet function: snippet(table, column_index, before, after, ellipsis, max_tokens)
		// Column 1 is 'body' (0=title, 1=body in our FTS tables)
		bodyColumn = fmt.Sprintf("snippet(%s, 1, '<mark>', '</mark>', '...', 32)", q.config.FTSTable)
	}

	return fmt.Sprintf(`
SELECT 
    ct.%s,
    ct.title,
    %s as body,
    ct.created_at,
    -1.0 * rank as score
FROM %s
JOIN %s ct ON %s.rowid = ct.%s
WHERE %s MATCH ?
ORDER BY rank
LIMIT ? OFFSET ?`,
		q.config.IDColumn,
		bodyColumn,
		q.config.FTSTable,
		q.config.ContentTable,
		q.config.FTSTable,
		q.config.ContentRowID,
		q.config.FTSTable,
	)
}

// buildCountQuery constructs the FTS count query string.
func (q *FTSQuerier) buildCountQuery() string {
	return fmt.Sprintf(`SELECT COUNT(*) FROM %s WHERE %s MATCH ?`,
		q.config.FTSTable,
		q.config.FTSTable,
	)
}

// FTSSearchResult represents a single FTS search result.
// This is a concrete type returned by the querier.
type FTSSearchResult struct {
	ID        int64     `json:"id"`
	Title     string    `json:"title"`
	Body      string    `json:"body"` // Full body or snippet depending on query
	CreatedAt time.Time `json:"created_at"`
	Score     float64   `json:"score"` // FTS5 rank score (higher = better match)
}

// Search performs full-text search and returns results with full body text.
//
// SECURITY: The query parameter is sanitized via SanitizeFTS5Query() before use,
// and all parameters are passed via parameterized statements.
func (q *FTSQuerier) Search(ctx context.Context, params FTSSearchParams) ([]FTSSearchResult, error) {
	// Sanitize query to prevent FTS5 syntax errors and injection
	sanitizedQuery := SanitizeFTS5Query(params.Query)

	rows, err := q.db.QueryContext(ctx, q.searchQuery,
		sanitizedQuery,
		params.LimitCount,
		params.OffsetCount,
	)
	if err != nil {
		return nil, fmt.Errorf("fts search failed: %w", err)
	}
	defer rows.Close()

	var results []FTSSearchResult
	for rows.Next() {
		var r FTSSearchResult
		var body sql.NullString
		if err := rows.Scan(&r.ID, &r.Title, &body, &r.CreatedAt, &r.Score); err != nil {
			return nil, fmt.Errorf("failed to scan fts result: %w", err)
		}
		if body.Valid {
			r.Body = body.String
		}
		results = append(results, r)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("fts search iteration failed: %w", err)
	}

	return results, nil
}

// SearchWithSnippet performs full-text search and returns results with HTML-highlighted snippets.
// Snippets use <mark> tags to highlight matching terms.
//
// SECURITY: The query parameter is sanitized via SanitizeFTS5Query() before use,
// and all parameters are passed via parameterized statements.
func (q *FTSQuerier) SearchWithSnippet(ctx context.Context, params FTSSearchParams) ([]FTSSearchResult, error) {
	// Sanitize query to prevent FTS5 syntax errors and injection
	sanitizedQuery := SanitizeFTS5Query(params.Query)

	rows, err := q.db.QueryContext(ctx, q.searchSnippetQuery,
		sanitizedQuery,
		params.LimitCount,
		params.OffsetCount,
	)
	if err != nil {
		return nil, fmt.Errorf("fts search with snippet failed: %w", err)
	}
	defer rows.Close()

	var results []FTSSearchResult
	for rows.Next() {
		var r FTSSearchResult
		var body sql.NullString
		if err := rows.Scan(&r.ID, &r.Title, &body, &r.CreatedAt, &r.Score); err != nil {
			return nil, fmt.Errorf("failed to scan fts snippet result: %w", err)
		}
		if body.Valid {
			r.Body = body.String
		}
		results = append(results, r)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("fts snippet search iteration failed: %w", err)
	}

	return results, nil
}

// Count returns the total number of documents matching the search query.
// Useful for pagination.
//
// SECURITY: The query parameter is sanitized via SanitizeFTS5Query() before use,
// and passed via parameterized statement.
func (q *FTSQuerier) Count(ctx context.Context, query string) (int64, error) {
	// Sanitize query to prevent FTS5 syntax errors and injection
	sanitizedQuery := SanitizeFTS5Query(query)

	row := q.db.QueryRowContext(ctx, q.countQuery, sanitizedQuery)

	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("fts count failed: %w", err)
	}

	return count, nil
}
