// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notes_search.sql

package store

import (
	"context"
	"database/sql"
)

const getNoteByIDForRAG = `-- name: GetNoteByIDForRAG :one

SELECT 
    id,
    title,
    body,
    note_type_id,
    created_at
FROM notes
WHERE id = ?1
`

type GetNoteByIDForRAGRow struct {
	ID         int64          `json:"id"`
	Title      string         `json:"title"`
	Body       sql.NullString `json:"body"`
	NoteTypeID sql.NullInt64  `json:"note_type_id"`
	CreatedAt  sql.NullTime   `json:"created_at"`
}

// notes_search.sql
// Search and related queries for notes
// NOTE: FTS5 queries are in internal/mind/store/fts_queries.go (SQLC can't handle FTS5 virtual tables)
// Get a single note with minimal fields for RAG context
func (q *Queries) GetNoteByIDForRAG(ctx context.Context, id int64) (GetNoteByIDForRAGRow, error) {
	row := q.db.QueryRowContext(ctx, getNoteByIDForRAG, id)
	var i GetNoteByIDForRAGRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.NoteTypeID,
		&i.CreatedAt,
	)
	return i, err
}

const getRelatedNotesByBackwardLinks = `-- name: GetRelatedNotesByBackwardLinks :many
SELECT DISTINCT
    n.id,
    n.title,
    substr(n.body, 1, 200) as snippet,
    n.note_type_id,
    n.created_at
FROM notes n
JOIN links nl ON n.id = nl.src_id
WHERE nl.dest_id = ?1
LIMIT ?2
`

type GetRelatedNotesByBackwardLinksParams struct {
	NoteID     sql.NullInt64 `json:"note_id"`
	LimitCount int64         `json:"limit_count"`
}

type GetRelatedNotesByBackwardLinksRow struct {
	ID         int64         `json:"id"`
	Title      string        `json:"title"`
	Snippet    string        `json:"snippet"`
	NoteTypeID sql.NullInt64 `json:"note_type_id"`
	CreatedAt  sql.NullTime  `json:"created_at"`
}

// Find notes linking to this note (backward links)
func (q *Queries) GetRelatedNotesByBackwardLinks(ctx context.Context, arg GetRelatedNotesByBackwardLinksParams) ([]GetRelatedNotesByBackwardLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedNotesByBackwardLinks, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedNotesByBackwardLinksRow
	for rows.Next() {
		var i GetRelatedNotesByBackwardLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteTypeID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedNotesByForwardLinks = `-- name: GetRelatedNotesByForwardLinks :many
SELECT DISTINCT
    n.id,
    n.title,
    substr(n.body, 1, 200) as snippet,
    n.note_type_id,
    n.created_at
FROM notes n
JOIN links nl ON n.id = nl.dest_id
WHERE nl.src_id = ?1
LIMIT ?2
`

type GetRelatedNotesByForwardLinksParams struct {
	NoteID     int64 `json:"note_id"`
	LimitCount int64 `json:"limit_count"`
}

type GetRelatedNotesByForwardLinksRow struct {
	ID         int64         `json:"id"`
	Title      string        `json:"title"`
	Snippet    string        `json:"snippet"`
	NoteTypeID sql.NullInt64 `json:"note_type_id"`
	CreatedAt  sql.NullTime  `json:"created_at"`
}

// Find notes linked from this note (forward links)
func (q *Queries) GetRelatedNotesByForwardLinks(ctx context.Context, arg GetRelatedNotesByForwardLinksParams) ([]GetRelatedNotesByForwardLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedNotesByForwardLinks, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedNotesByForwardLinksRow
	for rows.Next() {
		var i GetRelatedNotesByForwardLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteTypeID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedNotesByTags = `-- name: GetRelatedNotesByTags :many
SELECT DISTINCT
    n.id,
    n.title,
    substr(n.body, 1, 200) as snippet,
    n.note_type_id,
    n.created_at,
    COUNT(DISTINCT nt2.tag_id) as shared_tags
FROM notes n
JOIN note_tags nt2 ON n.id = nt2.note_id
JOIN note_tags nt1 ON nt1.tag_id = nt2.tag_id
WHERE nt1.note_id = ?1
AND n.id != ?1
GROUP BY n.id, n.title, n.body, n.note_type_id, n.created_at
ORDER BY shared_tags DESC
LIMIT ?2
`

type GetRelatedNotesByTagsParams struct {
	NoteID     int64 `json:"note_id"`
	LimitCount int64 `json:"limit_count"`
}

type GetRelatedNotesByTagsRow struct {
	ID         int64         `json:"id"`
	Title      string        `json:"title"`
	Snippet    string        `json:"snippet"`
	NoteTypeID sql.NullInt64 `json:"note_type_id"`
	CreatedAt  sql.NullTime  `json:"created_at"`
	SharedTags int64         `json:"shared_tags"`
}

// Find notes with shared tags
func (q *Queries) GetRelatedNotesByTags(ctx context.Context, arg GetRelatedNotesByTagsParams) ([]GetRelatedNotesByTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedNotesByTags, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedNotesByTagsRow
	for rows.Next() {
		var i GetRelatedNotesByTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteTypeID,
			&i.CreatedAt,
			&i.SharedTags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
