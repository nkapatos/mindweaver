// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package store

import (
	"context"
)

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTagsForNote = `-- name: CountTagsForNote :one
SELECT COUNT(*) FROM tags
JOIN note_tags ON tags.id = note_tags.tag_id
WHERE note_tags.note_id = ?1
`

func (q *Queries) CountTagsForNote(ctx context.Context, noteID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTagsForNote, noteID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNoteTag = `-- name: CreateNoteTag :exec
INSERT INTO note_tags (note_id, tag_id)
VALUES (?1, ?2)
`

type CreateNoteTagParams struct {
	NoteID int64 `json:"note_id"`
	TagID  int64 `json:"tag_id"`
}

func (q *Queries) CreateNoteTag(ctx context.Context, arg CreateNoteTagParams) error {
	_, err := q.db.ExecContext(ctx, createNoteTag, arg.NoteID, arg.TagID)
	return err
}

const createTag = `-- name: CreateTag :execlastid

INSERT INTO tags (name, created_at, updated_at)
VALUES (?1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
`

// tags.sql
// Pass 3: CRUD + advanced queries for tags and note_tags (SQLite, sqlc compatible)
// sqlc annotations added for code generation
// Included: insert, select by id, select all, update by id, delete by id, advanced queries for tag search and usage
// Next: Consider more advanced tag suggestions, filtering, and usage analytics
func (q *Queries) CreateTag(ctx context.Context, name string) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTag, name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteNoteTag = `-- name: DeleteNoteTag :exec
DELETE FROM note_tags WHERE note_id = ?1 AND tag_id = ?2
`

type DeleteNoteTagParams struct {
	NoteID int64 `json:"note_id"`
	TagID  int64 `json:"tag_id"`
}

func (q *Queries) DeleteNoteTag(ctx context.Context, arg DeleteNoteTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteNoteTag, arg.NoteID, arg.TagID)
	return err
}

const deleteNoteTagsByNoteID = `-- name: DeleteNoteTagsByNoteID :exec
DELETE FROM note_tags WHERE note_id = ?1
`

func (q *Queries) DeleteNoteTagsByNoteID(ctx context.Context, noteID int64) error {
	_, err := q.db.ExecContext(ctx, deleteNoteTagsByNoteID, noteID)
	return err
}

const deleteTagByID = `-- name: DeleteTagByID :exec
DELETE FROM tags WHERE id = ?1
`

func (q *Queries) DeleteTagByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTagByID, id)
	return err
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, created_at, updated_at FROM tags WHERE id = ?1
`

func (q *Queries) GetTagByID(ctx context.Context, id int64) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, created_at, updated_at FROM tags WHERE name = ?1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listNoteTags = `-- name: ListNoteTags :many
SELECT note_id, tag_id FROM note_tags ORDER BY note_id, tag_id
`

func (q *Queries) ListNoteTags(ctx context.Context) ([]NoteTag, error) {
	rows, err := q.db.QueryContext(ctx, listNoteTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteTag
	for rows.Next() {
		var i NoteTag
		if err := rows.Scan(&i.NoteID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoteTagsByNoteID = `-- name: ListNoteTagsByNoteID :many
SELECT note_id, tag_id FROM note_tags WHERE note_id = ?1
`

func (q *Queries) ListNoteTagsByNoteID(ctx context.Context, noteID int64) ([]NoteTag, error) {
	rows, err := q.db.QueryContext(ctx, listNoteTagsByNoteID, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteTag
	for rows.Next() {
		var i NoteTag
		if err := rows.Scan(&i.NoteID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoteTagsByTagID = `-- name: ListNoteTagsByTagID :many
SELECT note_id, tag_id FROM note_tags WHERE tag_id = ?1
`

func (q *Queries) ListNoteTagsByTagID(ctx context.Context, tagID int64) ([]NoteTag, error) {
	rows, err := q.db.QueryContext(ctx, listNoteTagsByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteTag
	for rows.Next() {
		var i NoteTag
		if err := rows.Scan(&i.NoteID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesForTag = `-- name: ListNotesForTag :many
SELECT notes.id, notes.uuid, notes.title, notes.body, notes.description, notes.frontmatter, notes.created_at, notes.updated_at, notes.version, notes.note_type_id, notes.collection_id, notes.is_template FROM notes
JOIN note_tags ON notes.id = note_tags.note_id
WHERE note_tags.tag_id = ?1
`

func (q *Queries) ListNotesForTag(ctx context.Context, tagID int64) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesForTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name, created_at, updated_at FROM tags ORDER BY id
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsForNote = `-- name: ListTagsForNote :many
SELECT tags.id, tags.name, tags.created_at, tags.updated_at FROM tags
JOIN note_tags ON tags.id = note_tags.tag_id
WHERE note_tags.note_id = ?1
`

func (q *Queries) ListTagsForNote(ctx context.Context, noteID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsForNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsForNotePaginated = `-- name: ListTagsForNotePaginated :many
SELECT tags.id, tags.name, tags.created_at, tags.updated_at FROM tags
JOIN note_tags ON tags.id = note_tags.tag_id
WHERE note_tags.note_id = ?1
ORDER BY tags.id
LIMIT ?3 OFFSET ?2
`

type ListTagsForNotePaginatedParams struct {
	NoteID int64 `json:"note_id"`
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListTagsForNotePaginated(ctx context.Context, arg ListTagsForNotePaginatedParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsForNotePaginated, arg.NoteID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsPaginated = `-- name: ListTagsPaginated :many

SELECT id, name, created_at, updated_at FROM tags 
ORDER BY id
LIMIT ?2 OFFSET ?1
`

type ListTagsPaginatedParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

// ========================================
// Paginated Queries (AIP-158)
// ========================================
func (q *Queries) ListTagsPaginated(ctx context.Context, arg ListTagsPaginatedParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsPaginated, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTagsByName = `-- name: SearchTagsByName :many
SELECT id, name, created_at, updated_at FROM tags WHERE name LIKE ?1
`

func (q *Queries) SearchTagsByName(ctx context.Context, namePattern string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, searchTagsByName, namePattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagUsageCount = `-- name: TagUsageCount :many
SELECT tag_id, COUNT(*) as usage_count FROM note_tags GROUP BY tag_id ORDER BY usage_count DESC
`

type TagUsageCountRow struct {
	TagID      int64 `json:"tag_id"`
	UsageCount int64 `json:"usage_count"`
}

func (q *Queries) TagUsageCount(ctx context.Context) ([]TagUsageCountRow, error) {
	rows, err := q.db.QueryContext(ctx, tagUsageCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagUsageCountRow
	for rows.Next() {
		var i TagUsageCountRow
		if err := rows.Scan(&i.TagID, &i.UsageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTagByID = `-- name: UpdateTagByID :exec
UPDATE tags
SET name = ?1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
`

type UpdateTagByIDParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateTagByID(ctx context.Context, arg UpdateTagByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateTagByID, arg.Name, arg.ID)
	return err
}
