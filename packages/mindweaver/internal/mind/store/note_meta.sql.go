// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: note_meta.sql

package store

import (
	"context"
	"database/sql"
)

const createNoteMeta = `-- name: CreateNoteMeta :execlastid
INSERT INTO note_meta (note_id, key, value)
VALUES (?1, ?2, ?3)
`

type CreateNoteMetaParams struct {
	NoteID int64          `json:"note_id"`
	Key    string         `json:"key"`
	Value  sql.NullString `json:"value"`
}

func (q *Queries) CreateNoteMeta(ctx context.Context, arg CreateNoteMetaParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createNoteMeta, arg.NoteID, arg.Key, arg.Value)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteNoteMetaByID = `-- name: DeleteNoteMetaByID :exec
DELETE FROM note_meta WHERE id = ?1
`

func (q *Queries) DeleteNoteMetaByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteNoteMetaByID, id)
	return err
}

const deleteNoteMetaByNoteID = `-- name: DeleteNoteMetaByNoteID :exec
DELETE FROM note_meta WHERE note_id = ?1
`

func (q *Queries) DeleteNoteMetaByNoteID(ctx context.Context, noteID int64) error {
	_, err := q.db.ExecContext(ctx, deleteNoteMetaByNoteID, noteID)
	return err
}

const getNoteMetaByID = `-- name: GetNoteMetaByID :one
SELECT id, note_id, "key", value, created_at, updated_at FROM note_meta WHERE id = ?1
`

func (q *Queries) GetNoteMetaByID(ctx context.Context, id int64) (NoteMetum, error) {
	row := q.db.QueryRowContext(ctx, getNoteMetaByID, id)
	var i NoteMetum
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNoteMetaByNoteID = `-- name: GetNoteMetaByNoteID :many

SELECT id, note_id, "key", value, created_at, updated_at FROM note_meta WHERE note_id = ?1 ORDER BY key
`

// ========================================
// Composite Queries - Note Meta with Notes
// ========================================
func (q *Queries) GetNoteMetaByNoteID(ctx context.Context, noteID int64) ([]NoteMetum, error) {
	rows, err := q.db.QueryContext(ctx, getNoteMetaByNoteID, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteMetum
	for rows.Next() {
		var i NoteMetum
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctNoteMetaKeys = `-- name: ListDistinctNoteMetaKeys :many
SELECT DISTINCT key FROM note_meta ORDER BY key
`

func (q *Queries) ListDistinctNoteMetaKeys(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDistinctNoteMetaKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoteMeta = `-- name: ListNoteMeta :many
SELECT id, note_id, "key", value, created_at, updated_at FROM note_meta ORDER BY id
`

func (q *Queries) ListNoteMeta(ctx context.Context) ([]NoteMetum, error) {
	rows, err := q.db.QueryContext(ctx, listNoteMeta)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteMetum
	for rows.Next() {
		var i NoteMetum
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoteMetaByKey = `-- name: ListNoteMetaByKey :many

SELECT id, note_id, "key", value, created_at, updated_at FROM note_meta WHERE key = ?1
`

// note_meta.sql
// Pass 4: CRUD + advanced queries for note_meta (SQLite, sqlc compatible)
// sqlc annotations added for code generation
// Timestamps managed by DB. Optimized with composite index (note_id, key).
// Included: insert, select by id, select all, update by id, delete by id, advanced queries
// UPSERT support added for bulk meta operations
func (q *Queries) ListNoteMetaByKey(ctx context.Context, key string) ([]NoteMetum, error) {
	rows, err := q.db.QueryContext(ctx, listNoteMetaByKey, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteMetum
	for rows.Next() {
		var i NoteMetum
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoteMetaByKeyValuePattern = `-- name: ListNoteMetaByKeyValuePattern :many
SELECT id, note_id, "key", value, created_at, updated_at FROM note_meta WHERE key = ?1 AND value LIKE ?2
`

type ListNoteMetaByKeyValuePatternParams struct {
	Key          string         `json:"key"`
	ValuePattern sql.NullString `json:"value_pattern"`
}

func (q *Queries) ListNoteMetaByKeyValuePattern(ctx context.Context, arg ListNoteMetaByKeyValuePatternParams) ([]NoteMetum, error) {
	rows, err := q.db.QueryContext(ctx, listNoteMetaByKeyValuePattern, arg.Key, arg.ValuePattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteMetum
	for rows.Next() {
		var i NoteMetum
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNoteMetaByKeys = `-- name: ListNoteMetaByKeys :many
SELECT id, note_id, "key", value, created_at, updated_at FROM note_meta WHERE key IN (?1)
`

func (q *Queries) ListNoteMetaByKeys(ctx context.Context, keys string) ([]NoteMetum, error) {
	rows, err := q.db.QueryContext(ctx, listNoteMetaByKeys, keys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NoteMetum
	for rows.Next() {
		var i NoteMetum
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNoteMetaByID = `-- name: UpdateNoteMetaByID :exec
UPDATE note_meta
SET note_id = ?1,
    key = ?2,
    value = ?3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
`

type UpdateNoteMetaByIDParams struct {
	NoteID int64          `json:"note_id"`
	Key    string         `json:"key"`
	Value  sql.NullString `json:"value"`
	ID     int64          `json:"id"`
}

func (q *Queries) UpdateNoteMetaByID(ctx context.Context, arg UpdateNoteMetaByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateNoteMetaByID,
		arg.NoteID,
		arg.Key,
		arg.Value,
		arg.ID,
	)
	return err
}

const upsertNoteMeta = `-- name: UpsertNoteMeta :exec
INSERT INTO note_meta (note_id, key, value)
VALUES (?1, ?2, ?3)
ON CONFLICT (note_id, key) 
DO UPDATE SET 
    value = excluded.value,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertNoteMetaParams struct {
	NoteID int64          `json:"note_id"`
	Key    string         `json:"key"`
	Value  sql.NullString `json:"value"`
}

func (q *Queries) UpsertNoteMeta(ctx context.Context, arg UpsertNoteMetaParams) error {
	_, err := q.db.ExecContext(ctx, upsertNoteMeta, arg.NoteID, arg.Key, arg.Value)
	return err
}
