// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package store

import (
	"context"
	"database/sql"
)

const countBrokenLinks = `-- name: CountBrokenLinks :one
SELECT COUNT(*) FROM links WHERE resolved = -1
`

func (q *Queries) CountBrokenLinks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBrokenLinks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnresolvedLinks = `-- name: CountUnresolvedLinks :one
SELECT COUNT(*) FROM links WHERE resolved = 0
`

func (q *Queries) CountUnresolvedLinks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnresolvedLinks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLink = `-- name: CreateLink :execlastid
INSERT INTO links (src_id, dest_id, display_text, is_embed)
VALUES (?1, ?2, ?3, ?4)
`

type CreateLinkParams struct {
	SrcID       int64          `json:"src_id"`
	DestID      sql.NullInt64  `json:"dest_id"`
	DisplayText sql.NullString `json:"display_text"`
	IsEmbed     sql.NullBool   `json:"is_embed"`
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createLink,
		arg.SrcID,
		arg.DestID,
		arg.DisplayText,
		arg.IsEmbed,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createUnresolvedLink = `-- name: CreateUnresolvedLink :execlastid
INSERT INTO links (
    src_id, dest_id, dest_title, display_text, is_embed, resolved
)
VALUES (?1, NULL, ?2, ?3, ?4, 0)
`

type CreateUnresolvedLinkParams struct {
	SrcID       int64          `json:"src_id"`
	DestTitle   sql.NullString `json:"dest_title"`
	DisplayText sql.NullString `json:"display_text"`
	IsEmbed     sql.NullBool   `json:"is_embed"`
}

func (q *Queries) CreateUnresolvedLink(ctx context.Context, arg CreateUnresolvedLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createUnresolvedLink,
		arg.SrcID,
		arg.DestTitle,
		arg.DisplayText,
		arg.IsEmbed,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteLinksBySrcID = `-- name: DeleteLinksBySrcID :exec
DELETE FROM links WHERE src_id = ?1
`

func (q *Queries) DeleteLinksBySrcID(ctx context.Context, srcID int64) error {
	_, err := q.db.ExecContext(ctx, deleteLinksBySrcID, srcID)
	return err
}

const findUnresolvedLinksByDestTitle = `-- name: FindUnresolvedLinksByDestTitle :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links
WHERE
    resolved = 0
    AND dest_id IS NULL
    AND dest_title = ?1
`

// Finds unresolved links that point to a specific note title
// Used when creating a note to resolve pending links
func (q *Queries) FindUnresolvedLinksByDestTitle(ctx context.Context, destTitle sql.NullString) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, findUnresolvedLinksByDestTitle, destTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkByID = `-- name: GetLinkByID :one
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links WHERE id = ?1
`

func (q *Queries) GetLinkByID(ctx context.Context, id int64) (Link, error) {
	row := q.db.QueryRowContext(ctx, getLinkByID, id)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.SrcID,
		&i.DestID,
		&i.DestTitle,
		&i.DisplayText,
		&i.IsEmbed,
		&i.Resolved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBrokenLinks = `-- name: ListBrokenLinks :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links WHERE resolved = -1 ORDER BY id
`

func (q *Queries) ListBrokenLinks(ctx context.Context) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listBrokenLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinks = `-- name: ListLinks :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links ORDER BY id
`

func (q *Queries) ListLinks(ctx context.Context) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinksByDestID = `-- name: ListLinksByDestID :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links WHERE dest_id = ?1
`

func (q *Queries) ListLinksByDestID(ctx context.Context, destID sql.NullInt64) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listLinksByDestID, destID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinksBySrcID = `-- name: ListLinksBySrcID :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links WHERE src_id = ?1
`

func (q *Queries) ListLinksBySrcID(ctx context.Context, srcID int64) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listLinksBySrcID, srcID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrphanedLinks = `-- name: ListOrphanedLinks :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links
WHERE dest_id IS NULL
ORDER BY src_id, dest_title
`

// Returns links where destination note no longer exists (dest_id IS NULL)
// Used for "broken links" UI view (BR-03: Knowledge Preservation)
func (q *Queries) ListOrphanedLinks(ctx context.Context) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listOrphanedLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnresolvedLinks = `-- name: ListUnresolvedLinks :many

SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links
WHERE resolved IN (0, -1)
ORDER BY id
LIMIT ?1
`

// ========================================
// WikiLink Resolution Queries
// ========================================
// Gets both pending (0) and broken (-1) links for resolution
// Broken links can become resolved if the target note is created later
func (q *Queries) ListUnresolvedLinks(ctx context.Context, limit int64) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, listUnresolvedLinks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markLinkBroken = `-- name: MarkLinkBroken :exec
UPDATE links
SET resolved = -1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
`

func (q *Queries) MarkLinkBroken(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markLinkBroken, id)
	return err
}

const resolveLink = `-- name: ResolveLink :exec
UPDATE links
SET dest_id = ?1,
    dest_title = NULL,
    resolved = 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
`

type ResolveLinkParams struct {
	DestID sql.NullInt64 `json:"dest_id"`
	ID     int64         `json:"id"`
}

// Resolves a pending link by setting dest_id and clearing dest_title
// dest_title is only kept for unresolved (0) and broken (-1) links
func (q *Queries) ResolveLink(ctx context.Context, arg ResolveLinkParams) error {
	_, err := q.db.ExecContext(ctx, resolveLink, arg.DestID, arg.ID)
	return err
}

const searchLinksByDisplayText = `-- name: SearchLinksByDisplayText :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM links WHERE display_text LIKE ?1
`

func (q *Queries) SearchLinksByDisplayText(ctx context.Context, displayTextPattern sql.NullString) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, searchLinksByDisplayText, displayTextPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
