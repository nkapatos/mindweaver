// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assistant_notes.sql

package store

import (
	"context"
	"database/sql"
)

const countAssistantNotes = `-- name: CountAssistantNotes :one
SELECT COUNT(*) FROM assistant_notes
`

func (q *Queries) CountAssistantNotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAssistantNotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAssistantNote = `-- name: CreateAssistantNote :execlastid

INSERT INTO assistant_notes (uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12)
`

type CreateAssistantNoteParams struct {
	Uuid                  string         `json:"uuid"`
	Title                 string         `json:"title"`
	Body                  string         `json:"body"`
	Description           sql.NullString `json:"description"`
	NoteType              sql.NullString `json:"note_type"`
	RelatedConversationID sql.NullInt64  `json:"related_conversation_id"`
	RelatedNoteID         sql.NullInt64  `json:"related_note_id"`
	CreatedByAssistantID  sql.NullInt64  `json:"created_by_assistant_id"`
	Priority              sql.NullInt64  `json:"priority"`
	DueDate               sql.NullTime   `json:"due_date"`
	IsCompleted           sql.NullBool   `json:"is_completed"`
	IsActive              sql.NullBool   `json:"is_active"`
}

// assistant_notes.sql
// CRUD operations for assistant_notes table
// Assistant's own notes and knowledge base (like user's notes)
// Follows the same pattern as notes.sql
func (q *Queries) CreateAssistantNote(ctx context.Context, arg CreateAssistantNoteParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createAssistantNote,
		arg.Uuid,
		arg.Title,
		arg.Body,
		arg.Description,
		arg.NoteType,
		arg.RelatedConversationID,
		arg.RelatedNoteID,
		arg.CreatedByAssistantID,
		arg.Priority,
		arg.DueDate,
		arg.IsCompleted,
		arg.IsActive,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteAssistantNoteByID = `-- name: DeleteAssistantNoteByID :exec
DELETE FROM assistant_notes WHERE id = ?1
`

func (q *Queries) DeleteAssistantNoteByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAssistantNoteByID, id)
	return err
}

const deleteAssistantNotesByLinkedNote = `-- name: DeleteAssistantNotesByLinkedNote :exec
DELETE FROM assistant_notes WHERE related_note_id = ?1
`

func (q *Queries) DeleteAssistantNotesByLinkedNote(ctx context.Context, relatedNoteID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteAssistantNotesByLinkedNote, relatedNoteID)
	return err
}

const getAssistantNoteByID = `-- name: GetAssistantNoteByID :one
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes WHERE id = ?1
`

func (q *Queries) GetAssistantNoteByID(ctx context.Context, id int64) (AssistantNote, error) {
	row := q.db.QueryRowContext(ctx, getAssistantNoteByID, id)
	var i AssistantNote
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.NoteType,
		&i.RelatedConversationID,
		&i.RelatedNoteID,
		&i.CreatedByAssistantID,
		&i.Priority,
		&i.DueDate,
		&i.IsCompleted,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssistantNoteByUUID = `-- name: GetAssistantNoteByUUID :one
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes WHERE uuid = ?1
`

func (q *Queries) GetAssistantNoteByUUID(ctx context.Context, uuid string) (AssistantNote, error) {
	row := q.db.QueryRowContext(ctx, getAssistantNoteByUUID, uuid)
	var i AssistantNote
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.NoteType,
		&i.RelatedConversationID,
		&i.RelatedNoteID,
		&i.CreatedByAssistantID,
		&i.Priority,
		&i.DueDate,
		&i.IsCompleted,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveAssistantNotes = `-- name: ListActiveAssistantNotes :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE is_active = 1 
ORDER BY created_at DESC
`

func (q *Queries) ListActiveAssistantNotes(ctx context.Context) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listActiveAssistantNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotes = `-- name: ListAssistantNotes :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes ORDER BY created_at DESC
`

func (q *Queries) ListAssistantNotes(ctx context.Context) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotesByAssistant = `-- name: ListAssistantNotesByAssistant :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE created_by_assistant_id = ?1 
ORDER BY created_at DESC
`

func (q *Queries) ListAssistantNotesByAssistant(ctx context.Context, createdByAssistantID sql.NullInt64) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByAssistant, createdByAssistantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotesByConversation = `-- name: ListAssistantNotesByConversation :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE related_conversation_id = ?1 
ORDER BY created_at DESC
`

func (q *Queries) ListAssistantNotesByConversation(ctx context.Context, relatedConversationID sql.NullInt64) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByConversation, relatedConversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotesByLinkedNote = `-- name: ListAssistantNotesByLinkedNote :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE related_note_id = ?1 
ORDER BY created_at DESC
`

func (q *Queries) ListAssistantNotesByLinkedNote(ctx context.Context, relatedNoteID sql.NullInt64) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByLinkedNote, relatedNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotesByPriority = `-- name: ListAssistantNotesByPriority :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE priority >= ?1 
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) ListAssistantNotesByPriority(ctx context.Context, minPriority sql.NullInt64) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByPriority, minPriority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotesByType = `-- name: ListAssistantNotesByType :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE note_type = ?1 
ORDER BY created_at DESC
`

func (q *Queries) ListAssistantNotesByType(ctx context.Context, noteType sql.NullString) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByType, noteType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE note_type = 'task' 
  AND is_completed = 0 
  AND is_active = 1 
ORDER BY priority DESC, due_date ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingReminders = `-- name: ListUpcomingReminders :many
SELECT id, uuid, title, body, description, note_type, related_conversation_id, related_note_id, created_by_assistant_id, priority, due_date, is_completed, is_active, created_at, updated_at FROM assistant_notes 
WHERE note_type = 'reminder' 
  AND is_completed = 0 
  AND is_active = 1 
  AND due_date <= ?1 
ORDER BY due_date ASC
`

func (q *Queries) ListUpcomingReminders(ctx context.Context, beforeDate sql.NullTime) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listUpcomingReminders, beforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAssistantNoteCompleted = `-- name: MarkAssistantNoteCompleted :exec
UPDATE assistant_notes
SET is_completed = 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
`

func (q *Queries) MarkAssistantNoteCompleted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markAssistantNoteCompleted, id)
	return err
}

const setAssistantNoteActive = `-- name: SetAssistantNoteActive :exec
UPDATE assistant_notes
SET is_active = ?1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
`

type SetAssistantNoteActiveParams struct {
	IsActive sql.NullBool `json:"is_active"`
	ID       int64        `json:"id"`
}

func (q *Queries) SetAssistantNoteActive(ctx context.Context, arg SetAssistantNoteActiveParams) error {
	_, err := q.db.ExecContext(ctx, setAssistantNoteActive, arg.IsActive, arg.ID)
	return err
}

const updateAssistantNoteByID = `-- name: UpdateAssistantNoteByID :exec
UPDATE assistant_notes
SET uuid = ?1,
    title = ?2,
    body = ?3,
    description = ?4,
    note_type = ?5,
    related_conversation_id = ?6,
    related_note_id = ?7,
    created_by_assistant_id = ?8,
    priority = ?9,
    due_date = ?10,
    is_completed = ?11,
    is_active = ?12,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?13
`

type UpdateAssistantNoteByIDParams struct {
	Uuid                  string         `json:"uuid"`
	Title                 string         `json:"title"`
	Body                  string         `json:"body"`
	Description           sql.NullString `json:"description"`
	NoteType              sql.NullString `json:"note_type"`
	RelatedConversationID sql.NullInt64  `json:"related_conversation_id"`
	RelatedNoteID         sql.NullInt64  `json:"related_note_id"`
	CreatedByAssistantID  sql.NullInt64  `json:"created_by_assistant_id"`
	Priority              sql.NullInt64  `json:"priority"`
	DueDate               sql.NullTime   `json:"due_date"`
	IsCompleted           sql.NullBool   `json:"is_completed"`
	IsActive              sql.NullBool   `json:"is_active"`
	ID                    int64          `json:"id"`
}

func (q *Queries) UpdateAssistantNoteByID(ctx context.Context, arg UpdateAssistantNoteByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateAssistantNoteByID,
		arg.Uuid,
		arg.Title,
		arg.Body,
		arg.Description,
		arg.NoteType,
		arg.RelatedConversationID,
		arg.RelatedNoteID,
		arg.CreatedByAssistantID,
		arg.Priority,
		arg.DueDate,
		arg.IsCompleted,
		arg.IsActive,
		arg.ID,
	)
	return err
}
