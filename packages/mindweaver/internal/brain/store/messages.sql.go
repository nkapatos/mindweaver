// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package store

import (
	"context"
	"database/sql"
)

const countMessagesByConversation = `-- name: CountMessagesByConversation :one
SELECT COUNT(*) as count 
FROM messages 
WHERE conversation_id = ?1
`

func (q *Queries) CountMessagesByConversation(ctx context.Context, conversationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesByConversation, conversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :execlastid

INSERT INTO messages (conversation_id, uuid, role, content, metadata, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
`

type CreateMessageParams struct {
	ConversationID int64          `json:"conversation_id"`
	Uuid           string         `json:"uuid"`
	Role           string         `json:"role"`
	Content        string         `json:"content"`
	Metadata       sql.NullString `json:"metadata"`
}

// messages.sql
// CRUD operations for messages table
// Manages chat messages within conversations
// Uses uuid v7 for ordering. Timestamps managed by DB.
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createMessage,
		arg.ConversationID,
		arg.Uuid,
		arg.Role,
		arg.Content,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteMessageByID = `-- name: DeleteMessageByID :exec
DELETE FROM messages WHERE id = ?1
`

func (q *Queries) DeleteMessageByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMessageByID, id)
	return err
}

const deleteMessagesByConversation = `-- name: DeleteMessagesByConversation :exec
DELETE FROM messages WHERE conversation_id = ?1
`

func (q *Queries) DeleteMessagesByConversation(ctx context.Context, conversationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMessagesByConversation, conversationID)
	return err
}

const getConversationHistory = `-- name: GetConversationHistory :many
SELECT 
    m.id, m.conversation_id, m.uuid, m.role, m.content, m.metadata, m.created_at, m.updated_at,
    c.title as conversation_title
FROM messages m
JOIN conversations c ON m.conversation_id = c.id
WHERE m.conversation_id = ?1
ORDER BY m.uuid ASC
`

type GetConversationHistoryRow struct {
	ID                int64          `json:"id"`
	ConversationID    int64          `json:"conversation_id"`
	Uuid              string         `json:"uuid"`
	Role              string         `json:"role"`
	Content           string         `json:"content"`
	Metadata          sql.NullString `json:"metadata"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	ConversationTitle string         `json:"conversation_title"`
}

func (q *Queries) GetConversationHistory(ctx context.Context, conversationID int64) ([]GetConversationHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationHistory, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationHistoryRow
	for rows.Next() {
		var i GetConversationHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.Uuid,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConversationTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMessageByConversation = `-- name: GetLatestMessageByConversation :one
SELECT id, conversation_id, uuid, role, content, metadata, created_at, updated_at FROM messages 
WHERE conversation_id = ?1 
ORDER BY uuid DESC 
LIMIT 1
`

func (q *Queries) GetLatestMessageByConversation(ctx context.Context, conversationID int64) (Message, error) {
	row := q.db.QueryRowContext(ctx, getLatestMessageByConversation, conversationID)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.Uuid,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, conversation_id, uuid, role, content, metadata, created_at, updated_at FROM messages WHERE id = ?1
`

func (q *Queries) GetMessageByID(ctx context.Context, id int64) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.Uuid,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageByUUID = `-- name: GetMessageByUUID :one
SELECT id, conversation_id, uuid, role, content, metadata, created_at, updated_at FROM messages WHERE uuid = ?1
`

func (q *Queries) GetMessageByUUID(ctx context.Context, uuid string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageByUUID, uuid)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.Uuid,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageWithConversation = `-- name: GetMessageWithConversation :one

SELECT 
    m.id, m.conversation_id, m.uuid, m.role, m.content, m.metadata, m.created_at, m.updated_at,
    c.id as conversation_id,
    c.title as conversation_title
FROM messages m
LEFT JOIN conversations c ON m.conversation_id = c.id
WHERE m.id = ?1
`

type GetMessageWithConversationRow struct {
	ID                int64          `json:"id"`
	ConversationID    int64          `json:"conversation_id"`
	Uuid              string         `json:"uuid"`
	Role              string         `json:"role"`
	Content           string         `json:"content"`
	Metadata          sql.NullString `json:"metadata"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	ConversationID_2  sql.NullInt64  `json:"conversation_id_2"`
	ConversationTitle sql.NullString `json:"conversation_title"`
}

// ========================================
// Composite Queries - Messages with Relations
// ========================================
func (q *Queries) GetMessageWithConversation(ctx context.Context, id int64) (GetMessageWithConversationRow, error) {
	row := q.db.QueryRowContext(ctx, getMessageWithConversation, id)
	var i GetMessageWithConversationRow
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.Uuid,
		&i.Role,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConversationID_2,
		&i.ConversationTitle,
	)
	return i, err
}

const listMessages = `-- name: ListMessages :many
SELECT id, conversation_id, uuid, role, content, metadata, created_at, updated_at FROM messages ORDER BY uuid
`

func (q *Queries) ListMessages(ctx context.Context) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.Uuid,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByConversation = `-- name: ListMessagesByConversation :many
SELECT id, conversation_id, uuid, role, content, metadata, created_at, updated_at FROM messages 
WHERE conversation_id = ?1 
ORDER BY uuid ASC
`

func (q *Queries) ListMessagesByConversation(ctx context.Context, conversationID int64) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesByConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.Uuid,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByRole = `-- name: ListMessagesByRole :many
SELECT id, conversation_id, uuid, role, content, metadata, created_at, updated_at FROM messages 
WHERE role = ?1 
ORDER BY uuid
`

func (q *Queries) ListMessagesByRole(ctx context.Context, role string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, listMessagesByRole, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.Uuid,
			&i.Role,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageByID = `-- name: UpdateMessageByID :exec
UPDATE messages
SET conversation_id = ?1,
    uuid = ?2,
    role = ?3,
    content = ?4,
    metadata = ?5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?6
`

type UpdateMessageByIDParams struct {
	ConversationID int64          `json:"conversation_id"`
	Uuid           string         `json:"uuid"`
	Role           string         `json:"role"`
	Content        string         `json:"content"`
	Metadata       sql.NullString `json:"metadata"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateMessageByID(ctx context.Context, arg UpdateMessageByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateMessageByID,
		arg.ConversationID,
		arg.Uuid,
		arg.Role,
		arg.Content,
		arg.Metadata,
		arg.ID,
	)
	return err
}
