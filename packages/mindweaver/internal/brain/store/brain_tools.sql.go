// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: brain_tools.sql

package store

import (
	"context"
	"database/sql"
)

const countTools = `-- name: CountTools :one
SELECT COUNT(*) FROM brain_tools
`

func (q *Queries) CountTools(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTools)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTool = `-- name: CreateTool :one
INSERT INTO brain_tools (
    uuid,
    name,
    description,
    tool_type,
    endpoint,
    parameters
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, uuid, name, description, tool_type, endpoint, parameters, created_at, updated_at
`

type CreateToolParams struct {
	Uuid        string         `json:"uuid"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	ToolType    string         `json:"tool_type"`
	Endpoint    sql.NullString `json:"endpoint"`
	Parameters  sql.NullString `json:"parameters"`
}

func (q *Queries) CreateTool(ctx context.Context, arg CreateToolParams) (BrainTool, error) {
	row := q.db.QueryRowContext(ctx, createTool,
		arg.Uuid,
		arg.Name,
		arg.Description,
		arg.ToolType,
		arg.Endpoint,
		arg.Parameters,
	)
	var i BrainTool
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.ToolType,
		&i.Endpoint,
		&i.Parameters,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTool = `-- name: DeleteTool :exec
DELETE FROM brain_tools WHERE uuid = ?
`

func (q *Queries) DeleteTool(ctx context.Context, uuid string) error {
	_, err := q.db.ExecContext(ctx, deleteTool, uuid)
	return err
}

const getAllTools = `-- name: GetAllTools :many
SELECT id, uuid, name, description, tool_type, endpoint, parameters, created_at, updated_at FROM brain_tools ORDER BY name
`

func (q *Queries) GetAllTools(ctx context.Context) ([]BrainTool, error) {
	rows, err := q.db.QueryContext(ctx, getAllTools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BrainTool
	for rows.Next() {
		var i BrainTool
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.ToolType,
			&i.Endpoint,
			&i.Parameters,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolByName = `-- name: GetToolByName :one

SELECT id, uuid, name, description, tool_type, endpoint, parameters, created_at, updated_at FROM brain_tools WHERE name = ?
`

// brain_tools stores available tools that Brain can execute
// These are seeded with core operations and can be dynamically queried
// by the small model to match user intent to executable tools
func (q *Queries) GetToolByName(ctx context.Context, name string) (BrainTool, error) {
	row := q.db.QueryRowContext(ctx, getToolByName, name)
	var i BrainTool
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.ToolType,
		&i.Endpoint,
		&i.Parameters,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getToolByUUID = `-- name: GetToolByUUID :one
SELECT id, uuid, name, description, tool_type, endpoint, parameters, created_at, updated_at FROM brain_tools WHERE uuid = ?
`

func (q *Queries) GetToolByUUID(ctx context.Context, uuid string) (BrainTool, error) {
	row := q.db.QueryRowContext(ctx, getToolByUUID, uuid)
	var i BrainTool
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.ToolType,
		&i.Endpoint,
		&i.Parameters,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getToolsByType = `-- name: GetToolsByType :many
SELECT id, uuid, name, description, tool_type, endpoint, parameters, created_at, updated_at FROM brain_tools WHERE tool_type = ? ORDER BY name
`

func (q *Queries) GetToolsByType(ctx context.Context, toolType string) ([]BrainTool, error) {
	rows, err := q.db.QueryContext(ctx, getToolsByType, toolType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BrainTool
	for rows.Next() {
		var i BrainTool
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.ToolType,
			&i.Endpoint,
			&i.Parameters,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchToolsByDescription = `-- name: SearchToolsByDescription :many
SELECT id, uuid, name, description, tool_type, endpoint, parameters, created_at, updated_at FROM brain_tools 
WHERE description LIKE '%' || ? || '%'
ORDER BY name
`

// Brain's LLM will use tool descriptions to select appropriate tools
func (q *Queries) SearchToolsByDescription(ctx context.Context, dollar_1 sql.NullString) ([]BrainTool, error) {
	rows, err := q.db.QueryContext(ctx, searchToolsByDescription, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BrainTool
	for rows.Next() {
		var i BrainTool
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.ToolType,
			&i.Endpoint,
			&i.Parameters,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTool = `-- name: UpdateTool :exec
UPDATE brain_tools 
SET description = ?,
    tool_type = ?,
    endpoint = ?,
    parameters = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE uuid = ?
`

type UpdateToolParams struct {
	Description string         `json:"description"`
	ToolType    string         `json:"tool_type"`
	Endpoint    sql.NullString `json:"endpoint"`
	Parameters  sql.NullString `json:"parameters"`
	Uuid        string         `json:"uuid"`
}

func (q *Queries) UpdateTool(ctx context.Context, arg UpdateToolParams) error {
	_, err := q.db.ExecContext(ctx, updateTool,
		arg.Description,
		arg.ToolType,
		arg.Endpoint,
		arg.Parameters,
		arg.Uuid,
	)
	return err
}
