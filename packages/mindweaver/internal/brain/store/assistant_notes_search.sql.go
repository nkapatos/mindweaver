// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assistant_notes_search.sql

package store

import (
	"context"
	"database/sql"
)

const getAssistantNoteByIDForRAG = `-- name: GetAssistantNoteByIDForRAG :one

SELECT 
    id,
    title,
    body,
    note_type,
    related_note_id,
    created_by_assistant_id,
    created_at
FROM assistant_notes
WHERE id = ?1
`

type GetAssistantNoteByIDForRAGRow struct {
	ID                   int64          `json:"id"`
	Title                string         `json:"title"`
	Body                 string         `json:"body"`
	NoteType             sql.NullString `json:"note_type"`
	RelatedNoteID        sql.NullInt64  `json:"related_note_id"`
	CreatedByAssistantID sql.NullInt64  `json:"created_by_assistant_id"`
	CreatedAt            sql.NullTime   `json:"created_at"`
}

// assistant_notes_search.sql
// Search and related queries for assistant_notes
// NOTE: FTS5 queries are in internal/brain/store/fts_queries.go (SQLC can't handle FTS5 virtual tables)
// Get a single assistant note with minimal fields for RAG context
func (q *Queries) GetAssistantNoteByIDForRAG(ctx context.Context, id int64) (GetAssistantNoteByIDForRAGRow, error) {
	row := q.db.QueryRowContext(ctx, getAssistantNoteByIDForRAG, id)
	var i GetAssistantNoteByIDForRAGRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.NoteType,
		&i.RelatedNoteID,
		&i.CreatedByAssistantID,
		&i.CreatedAt,
	)
	return i, err
}

const getRelatedAssistantNotesByBackwardLinks = `-- name: GetRelatedAssistantNotesByBackwardLinks :many
SELECT DISTINCT
    an.id,
    an.title,
    substr(an.body, 1, 200) as snippet,
    an.note_type,
    an.created_at
FROM assistant_notes an
JOIN assistant_note_links anl ON an.id = anl.src_note_id
WHERE anl.dest_note_id = ?1
LIMIT ?2
`

type GetRelatedAssistantNotesByBackwardLinksParams struct {
	NoteID     int64 `json:"note_id"`
	LimitCount int64 `json:"limit_count"`
}

type GetRelatedAssistantNotesByBackwardLinksRow struct {
	ID        int64          `json:"id"`
	Title     string         `json:"title"`
	Snippet   string         `json:"snippet"`
	NoteType  sql.NullString `json:"note_type"`
	CreatedAt sql.NullTime   `json:"created_at"`
}

// Find assistant notes linking to this note (backward links)
func (q *Queries) GetRelatedAssistantNotesByBackwardLinks(ctx context.Context, arg GetRelatedAssistantNotesByBackwardLinksParams) ([]GetRelatedAssistantNotesByBackwardLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedAssistantNotesByBackwardLinks, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedAssistantNotesByBackwardLinksRow
	for rows.Next() {
		var i GetRelatedAssistantNotesByBackwardLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedAssistantNotesByForwardLinks = `-- name: GetRelatedAssistantNotesByForwardLinks :many
SELECT DISTINCT
    an.id,
    an.title,
    substr(an.body, 1, 200) as snippet,
    an.note_type,
    an.created_at
FROM assistant_notes an
JOIN assistant_note_links anl ON an.id = anl.dest_note_id
WHERE anl.src_note_id = ?1
LIMIT ?2
`

type GetRelatedAssistantNotesByForwardLinksParams struct {
	NoteID     int64 `json:"note_id"`
	LimitCount int64 `json:"limit_count"`
}

type GetRelatedAssistantNotesByForwardLinksRow struct {
	ID        int64          `json:"id"`
	Title     string         `json:"title"`
	Snippet   string         `json:"snippet"`
	NoteType  sql.NullString `json:"note_type"`
	CreatedAt sql.NullTime   `json:"created_at"`
}

// Find assistant notes linked from this note (forward links)
func (q *Queries) GetRelatedAssistantNotesByForwardLinks(ctx context.Context, arg GetRelatedAssistantNotesByForwardLinksParams) ([]GetRelatedAssistantNotesByForwardLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedAssistantNotesByForwardLinks, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedAssistantNotesByForwardLinksRow
	for rows.Next() {
		var i GetRelatedAssistantNotesByForwardLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedAssistantNotesBySourceNote = `-- name: GetRelatedAssistantNotesBySourceNote :many
SELECT 
    an.id,
    an.title,
    substr(an.body, 1, 200) as snippet,
    an.note_type,
    an.created_at
FROM assistant_notes an
WHERE an.related_note_id = ?1
AND an.id != ?2
LIMIT ?3
`

type GetRelatedAssistantNotesBySourceNoteParams struct {
	RelatedNoteID sql.NullInt64 `json:"related_note_id"`
	NoteID        int64         `json:"note_id"`
	LimitCount    int64         `json:"limit_count"`
}

type GetRelatedAssistantNotesBySourceNoteRow struct {
	ID        int64          `json:"id"`
	Title     string         `json:"title"`
	Snippet   string         `json:"snippet"`
	NoteType  sql.NullString `json:"note_type"`
	CreatedAt sql.NullTime   `json:"created_at"`
}

// Find all observations related to the same source Mind note
func (q *Queries) GetRelatedAssistantNotesBySourceNote(ctx context.Context, arg GetRelatedAssistantNotesBySourceNoteParams) ([]GetRelatedAssistantNotesBySourceNoteRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedAssistantNotesBySourceNote, arg.RelatedNoteID, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedAssistantNotesBySourceNoteRow
	for rows.Next() {
		var i GetRelatedAssistantNotesBySourceNoteRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedAssistantNotesByTags = `-- name: GetRelatedAssistantNotesByTags :many
SELECT DISTINCT
    an.id,
    an.title,
    substr(an.body, 1, 200) as snippet,
    an.note_type,
    an.created_at,
    COUNT(DISTINCT ant2.tag_id) as shared_tags
FROM assistant_notes an
JOIN assistant_note_tags ant2 ON an.id = ant2.assistant_note_id
JOIN assistant_note_tags ant1 ON ant1.tag_id = ant2.tag_id
WHERE ant1.assistant_note_id = ?1
AND an.id != ?1
GROUP BY an.id, an.title, an.body, an.note_type, an.created_at
ORDER BY shared_tags DESC
LIMIT ?2
`

type GetRelatedAssistantNotesByTagsParams struct {
	NoteID     int64 `json:"note_id"`
	LimitCount int64 `json:"limit_count"`
}

type GetRelatedAssistantNotesByTagsRow struct {
	ID         int64          `json:"id"`
	Title      string         `json:"title"`
	Snippet    string         `json:"snippet"`
	NoteType   sql.NullString `json:"note_type"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	SharedTags int64          `json:"shared_tags"`
}

// Find assistant notes with shared tags
func (q *Queries) GetRelatedAssistantNotesByTags(ctx context.Context, arg GetRelatedAssistantNotesByTagsParams) ([]GetRelatedAssistantNotesByTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedAssistantNotesByTags, arg.NoteID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedAssistantNotesByTagsRow
	for rows.Next() {
		var i GetRelatedAssistantNotesByTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Snippet,
			&i.NoteType,
			&i.CreatedAt,
			&i.SharedTags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
