// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assistant_note_meta.sql

package store

import (
	"context"
	"database/sql"
)

const createAssistantNoteMeta = `-- name: CreateAssistantNoteMeta :exec

INSERT INTO assistant_note_meta (assistant_note_id, key, value)
VALUES (?, ?, ?)
ON CONFLICT(assistant_note_id, key) DO UPDATE SET value = excluded.value, updated_at = CURRENT_TIMESTAMP
`

type CreateAssistantNoteMetaParams struct {
	AssistantNoteID int64          `json:"assistant_note_id"`
	Key             string         `json:"key"`
	Value           sql.NullString `json:"value"`
}

// assistant_note_meta.sql
// CRUD operations for assistant_note_meta table
// EAV pattern for flexible key-value pairs on assistant notes
func (q *Queries) CreateAssistantNoteMeta(ctx context.Context, arg CreateAssistantNoteMetaParams) error {
	_, err := q.db.ExecContext(ctx, createAssistantNoteMeta, arg.AssistantNoteID, arg.Key, arg.Value)
	return err
}

const deleteAssistantNoteMetaByID = `-- name: DeleteAssistantNoteMetaByID :exec
DELETE FROM assistant_note_meta WHERE id = ?1
`

func (q *Queries) DeleteAssistantNoteMetaByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAssistantNoteMetaByID, id)
	return err
}

const deleteAssistantNoteMetaByKey = `-- name: DeleteAssistantNoteMetaByKey :exec
DELETE FROM assistant_note_meta 
WHERE assistant_note_id = ?1 AND key = ?2
`

type DeleteAssistantNoteMetaByKeyParams struct {
	AssistantNoteID int64  `json:"assistant_note_id"`
	Key             string `json:"key"`
}

func (q *Queries) DeleteAssistantNoteMetaByKey(ctx context.Context, arg DeleteAssistantNoteMetaByKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteAssistantNoteMetaByKey, arg.AssistantNoteID, arg.Key)
	return err
}

const getAssistantNoteMetaByID = `-- name: GetAssistantNoteMetaByID :one
SELECT id, assistant_note_id, "key", value, created_at, updated_at FROM assistant_note_meta WHERE id = ?1
`

func (q *Queries) GetAssistantNoteMetaByID(ctx context.Context, id int64) (AssistantNoteMetum, error) {
	row := q.db.QueryRowContext(ctx, getAssistantNoteMetaByID, id)
	var i AssistantNoteMetum
	err := row.Scan(
		&i.ID,
		&i.AssistantNoteID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssistantNoteMetaByKey = `-- name: GetAssistantNoteMetaByKey :one
SELECT id, assistant_note_id, "key", value, created_at, updated_at FROM assistant_note_meta 
WHERE assistant_note_id = ?1 AND key = ?2 
LIMIT 1
`

type GetAssistantNoteMetaByKeyParams struct {
	AssistantNoteID int64  `json:"assistant_note_id"`
	Key             string `json:"key"`
}

func (q *Queries) GetAssistantNoteMetaByKey(ctx context.Context, arg GetAssistantNoteMetaByKeyParams) (AssistantNoteMetum, error) {
	row := q.db.QueryRowContext(ctx, getAssistantNoteMetaByKey, arg.AssistantNoteID, arg.Key)
	var i AssistantNoteMetum
	err := row.Scan(
		&i.ID,
		&i.AssistantNoteID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAssistantNoteMetaByNoteID = `-- name: ListAssistantNoteMetaByNoteID :many
SELECT id, assistant_note_id, "key", value, created_at, updated_at FROM assistant_note_meta 
WHERE assistant_note_id = ?1 
ORDER BY key
`

func (q *Queries) ListAssistantNoteMetaByNoteID(ctx context.Context, assistantNoteID int64) ([]AssistantNoteMetum, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNoteMetaByNoteID, assistantNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNoteMetum
	for rows.Next() {
		var i AssistantNoteMetum
		if err := rows.Scan(
			&i.ID,
			&i.AssistantNoteID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssistantNotesByMetaKey = `-- name: ListAssistantNotesByMetaKey :many
SELECT DISTINCT an.id, an.uuid, an.title, an.body, an.description, an.note_type, an.related_conversation_id, an.related_note_id, an.created_by_assistant_id, an.priority, an.due_date, an.is_completed, an.is_active, an.created_at, an.updated_at FROM assistant_notes an
JOIN assistant_note_meta anm ON an.id = anm.assistant_note_id
WHERE anm.key = ?1
ORDER BY an.created_at DESC
`

func (q *Queries) ListAssistantNotesByMetaKey(ctx context.Context, key string) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByMetaKey, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssistantNoteMetaByID = `-- name: UpdateAssistantNoteMetaByID :exec
UPDATE assistant_note_meta
SET key = ?1,
    value = ?2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?3
`

type UpdateAssistantNoteMetaByIDParams struct {
	Key   string         `json:"key"`
	Value sql.NullString `json:"value"`
	ID    int64          `json:"id"`
}

func (q *Queries) UpdateAssistantNoteMetaByID(ctx context.Context, arg UpdateAssistantNoteMetaByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateAssistantNoteMetaByID, arg.Key, arg.Value, arg.ID)
	return err
}
