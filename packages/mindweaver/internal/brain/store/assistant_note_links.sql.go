// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assistant_note_links.sql

package store

import (
	"context"
	"database/sql"
)

const countLinksForNote = `-- name: CountLinksForNote :one
SELECT COUNT(*) as link_count
FROM assistant_note_links
WHERE src_note_id = ?1 OR dest_note_id = ?1
`

// Count how many links a note has (useful for finding "hub" notes)
func (q *Queries) CountLinksForNote(ctx context.Context, noteID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLinksForNote, noteID)
	var link_count int64
	err := row.Scan(&link_count)
	return link_count, err
}

const createAssistantNoteLink = `-- name: CreateAssistantNoteLink :one

INSERT INTO assistant_note_links (
    src_note_id,
    dest_note_id,
    link_type,
    context,
    created_by_assistant_id,
    strength
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
RETURNING id, src_note_id, dest_note_id, link_type, context, created_by_assistant_id, strength, created_at, updated_at
`

type CreateAssistantNoteLinkParams struct {
	SrcNoteID            int64           `json:"src_note_id"`
	DestNoteID           int64           `json:"dest_note_id"`
	LinkType             string          `json:"link_type"`
	Context              sql.NullString  `json:"context"`
	CreatedByAssistantID sql.NullInt64   `json:"created_by_assistant_id"`
	Strength             sql.NullFloat64 `json:"strength"`
}

// assistant_note_links.sql
// CRUD operations for assistant_note_links table
// Enables Brain to create knowledge graphs by linking its own notes
func (q *Queries) CreateAssistantNoteLink(ctx context.Context, arg CreateAssistantNoteLinkParams) (AssistantNoteLink, error) {
	row := q.db.QueryRowContext(ctx, createAssistantNoteLink,
		arg.SrcNoteID,
		arg.DestNoteID,
		arg.LinkType,
		arg.Context,
		arg.CreatedByAssistantID,
		arg.Strength,
	)
	var i AssistantNoteLink
	err := row.Scan(
		&i.ID,
		&i.SrcNoteID,
		&i.DestNoteID,
		&i.LinkType,
		&i.Context,
		&i.CreatedByAssistantID,
		&i.Strength,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllLinksForNote = `-- name: DeleteAllLinksForNote :exec
DELETE FROM assistant_note_links 
WHERE src_note_id = ?1 OR dest_note_id = ?1
`

// Delete all links involving a note (used when deleting a note)
func (q *Queries) DeleteAllLinksForNote(ctx context.Context, noteID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllLinksForNote, noteID)
	return err
}

const deleteAssistantNoteLink = `-- name: DeleteAssistantNoteLink :exec
DELETE FROM assistant_note_links WHERE id = ?1
`

func (q *Queries) DeleteAssistantNoteLink(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAssistantNoteLink, id)
	return err
}

const deleteAssistantNoteLinksBetween = `-- name: DeleteAssistantNoteLinksBetween :exec
DELETE FROM assistant_note_links 
WHERE (src_note_id = ?1 AND dest_note_id = ?2)
   OR (src_note_id = ?2 AND dest_note_id = ?1)
`

type DeleteAssistantNoteLinksBetweenParams struct {
	NoteID1 int64 `json:"note_id_1"`
	NoteID2 int64 `json:"note_id_2"`
}

// Delete all links between two specific notes
func (q *Queries) DeleteAssistantNoteLinksBetween(ctx context.Context, arg DeleteAssistantNoteLinksBetweenParams) error {
	_, err := q.db.ExecContext(ctx, deleteAssistantNoteLinksBetween, arg.NoteID1, arg.NoteID2)
	return err
}

const findStronglyConnectedNotes = `-- name: FindStronglyConnectedNotes :many
SELECT 
    an.id,
    an.title,
    an.note_type,
    COUNT(anl.id) as link_count
FROM assistant_notes an
LEFT JOIN assistant_note_links anl ON (an.id = anl.src_note_id OR an.id = anl.dest_note_id)
GROUP BY an.id
HAVING link_count >= :min_links
ORDER BY link_count DESC
LIMIT ?1
`

type FindStronglyConnectedNotesRow struct {
	ID        int64          `json:"id"`
	Title     string         `json:"title"`
	NoteType  sql.NullString `json:"note_type"`
	LinkCount int64          `json:"link_count"`
}

// Find notes with many connections (knowledge hubs)
func (q *Queries) FindStronglyConnectedNotes(ctx context.Context, limitCount int64) ([]FindStronglyConnectedNotesRow, error) {
	rows, err := q.db.QueryContext(ctx, findStronglyConnectedNotes, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindStronglyConnectedNotesRow
	for rows.Next() {
		var i FindStronglyConnectedNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.NoteType,
			&i.LinkCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssistantNoteLinkByID = `-- name: GetAssistantNoteLinkByID :one
SELECT id, src_note_id, dest_note_id, link_type, context, created_by_assistant_id, strength, created_at, updated_at FROM assistant_note_links WHERE id = ?1
`

func (q *Queries) GetAssistantNoteLinkByID(ctx context.Context, id int64) (AssistantNoteLink, error) {
	row := q.db.QueryRowContext(ctx, getAssistantNoteLinkByID, id)
	var i AssistantNoteLink
	err := row.Scan(
		&i.ID,
		&i.SrcNoteID,
		&i.DestNoteID,
		&i.LinkType,
		&i.Context,
		&i.CreatedByAssistantID,
		&i.Strength,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBacklinks = `-- name: GetBacklinks :many
SELECT 
    anl.id, anl.src_note_id, anl.dest_note_id, anl.link_type, anl.context, anl.created_by_assistant_id, anl.strength, anl.created_at, anl.updated_at,
    an.id as src_note_id,
    an.title as src_note_title,
    an.note_type as src_note_type
FROM assistant_note_links anl
JOIN assistant_notes an ON anl.src_note_id = an.id
WHERE anl.dest_note_id = ?1
ORDER BY anl.created_at DESC
`

type GetBacklinksRow struct {
	ID                   int64           `json:"id"`
	SrcNoteID            int64           `json:"src_note_id"`
	DestNoteID           int64           `json:"dest_note_id"`
	LinkType             string          `json:"link_type"`
	Context              sql.NullString  `json:"context"`
	CreatedByAssistantID sql.NullInt64   `json:"created_by_assistant_id"`
	Strength             sql.NullFloat64 `json:"strength"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	SrcNoteID_2          int64           `json:"src_note_id_2"`
	SrcNoteTitle         string          `json:"src_note_title"`
	SrcNoteType          sql.NullString  `json:"src_note_type"`
}

// Get all notes linked TO this note
func (q *Queries) GetBacklinks(ctx context.Context, destNoteID int64) ([]GetBacklinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getBacklinks, destNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBacklinksRow
	for rows.Next() {
		var i GetBacklinksRow
		if err := rows.Scan(
			&i.ID,
			&i.SrcNoteID,
			&i.DestNoteID,
			&i.LinkType,
			&i.Context,
			&i.CreatedByAssistantID,
			&i.Strength,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SrcNoteID_2,
			&i.SrcNoteTitle,
			&i.SrcNoteType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBidirectionalLinks = `-- name: GetBidirectionalLinks :many
SELECT DISTINCT
    CASE 
        WHEN anl.src_note_id = ?1 THEN anl.dest_note_id
        ELSE anl.src_note_id
    END as connected_note_id,
    an.title as connected_note_title,
    an.note_type as connected_note_type,
    anl.link_type,
    anl.context,
    anl.strength,
    CASE 
        WHEN anl.src_note_id = ?1 THEN 'forward'
        ELSE 'backward'
    END as direction
FROM assistant_note_links anl
JOIN assistant_notes an ON (
    CASE 
        WHEN anl.src_note_id = ?1 THEN anl.dest_note_id
        ELSE anl.src_note_id
    END = an.id
)
WHERE anl.src_note_id = ?1 OR anl.dest_note_id = ?1
ORDER BY anl.created_at DESC
`

type GetBidirectionalLinksRow struct {
	ConnectedNoteID    interface{}     `json:"connected_note_id"`
	ConnectedNoteTitle string          `json:"connected_note_title"`
	ConnectedNoteType  sql.NullString  `json:"connected_note_type"`
	LinkType           string          `json:"link_type"`
	Context            sql.NullString  `json:"context"`
	Strength           sql.NullFloat64 `json:"strength"`
	Direction          string          `json:"direction"`
}

// Get all notes connected to this note (both directions)
func (q *Queries) GetBidirectionalLinks(ctx context.Context, noteID int64) ([]GetBidirectionalLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getBidirectionalLinks, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBidirectionalLinksRow
	for rows.Next() {
		var i GetBidirectionalLinksRow
		if err := rows.Scan(
			&i.ConnectedNoteID,
			&i.ConnectedNoteTitle,
			&i.ConnectedNoteType,
			&i.LinkType,
			&i.Context,
			&i.Strength,
			&i.Direction,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForwardLinks = `-- name: GetForwardLinks :many
SELECT 
    anl.id, anl.src_note_id, anl.dest_note_id, anl.link_type, anl.context, anl.created_by_assistant_id, anl.strength, anl.created_at, anl.updated_at,
    an.id as dest_note_id,
    an.title as dest_note_title,
    an.note_type as dest_note_type
FROM assistant_note_links anl
JOIN assistant_notes an ON anl.dest_note_id = an.id
WHERE anl.src_note_id = ?1
ORDER BY anl.created_at DESC
`

type GetForwardLinksRow struct {
	ID                   int64           `json:"id"`
	SrcNoteID            int64           `json:"src_note_id"`
	DestNoteID           int64           `json:"dest_note_id"`
	LinkType             string          `json:"link_type"`
	Context              sql.NullString  `json:"context"`
	CreatedByAssistantID sql.NullInt64   `json:"created_by_assistant_id"`
	Strength             sql.NullFloat64 `json:"strength"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	DestNoteID_2         int64           `json:"dest_note_id_2"`
	DestNoteTitle        string          `json:"dest_note_title"`
	DestNoteType         sql.NullString  `json:"dest_note_type"`
}

// Get all notes linked FROM this note
func (q *Queries) GetForwardLinks(ctx context.Context, srcNoteID int64) ([]GetForwardLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getForwardLinks, srcNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetForwardLinksRow
	for rows.Next() {
		var i GetForwardLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.SrcNoteID,
			&i.DestNoteID,
			&i.LinkType,
			&i.Context,
			&i.CreatedByAssistantID,
			&i.Strength,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestNoteID_2,
			&i.DestNoteTitle,
			&i.DestNoteType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksByAssistant = `-- name: GetLinksByAssistant :many
SELECT 
    anl.id, anl.src_note_id, anl.dest_note_id, anl.link_type, anl.context, anl.created_by_assistant_id, anl.strength, anl.created_at, anl.updated_at,
    src.title as src_note_title,
    dest.title as dest_note_title
FROM assistant_note_links anl
JOIN assistant_notes src ON anl.src_note_id = src.id
JOIN assistant_notes dest ON anl.dest_note_id = dest.id
WHERE anl.created_by_assistant_id = ?1
ORDER BY anl.created_at DESC
`

type GetLinksByAssistantRow struct {
	ID                   int64           `json:"id"`
	SrcNoteID            int64           `json:"src_note_id"`
	DestNoteID           int64           `json:"dest_note_id"`
	LinkType             string          `json:"link_type"`
	Context              sql.NullString  `json:"context"`
	CreatedByAssistantID sql.NullInt64   `json:"created_by_assistant_id"`
	Strength             sql.NullFloat64 `json:"strength"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	SrcNoteTitle         string          `json:"src_note_title"`
	DestNoteTitle        string          `json:"dest_note_title"`
}

// Get all links created by a specific assistant
func (q *Queries) GetLinksByAssistant(ctx context.Context, createdByAssistantID sql.NullInt64) ([]GetLinksByAssistantRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinksByAssistant, createdByAssistantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksByAssistantRow
	for rows.Next() {
		var i GetLinksByAssistantRow
		if err := rows.Scan(
			&i.ID,
			&i.SrcNoteID,
			&i.DestNoteID,
			&i.LinkType,
			&i.Context,
			&i.CreatedByAssistantID,
			&i.Strength,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SrcNoteTitle,
			&i.DestNoteTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksByType = `-- name: GetLinksByType :many
SELECT 
    anl.id, anl.src_note_id, anl.dest_note_id, anl.link_type, anl.context, anl.created_by_assistant_id, anl.strength, anl.created_at, anl.updated_at,
    src.title as src_note_title,
    dest.title as dest_note_title
FROM assistant_note_links anl
JOIN assistant_notes src ON anl.src_note_id = src.id
JOIN assistant_notes dest ON anl.dest_note_id = dest.id
WHERE anl.link_type = ?1
ORDER BY anl.created_at DESC
`

type GetLinksByTypeRow struct {
	ID                   int64           `json:"id"`
	SrcNoteID            int64           `json:"src_note_id"`
	DestNoteID           int64           `json:"dest_note_id"`
	LinkType             string          `json:"link_type"`
	Context              sql.NullString  `json:"context"`
	CreatedByAssistantID sql.NullInt64   `json:"created_by_assistant_id"`
	Strength             sql.NullFloat64 `json:"strength"`
	CreatedAt            sql.NullTime    `json:"created_at"`
	UpdatedAt            sql.NullTime    `json:"updated_at"`
	SrcNoteTitle         string          `json:"src_note_title"`
	DestNoteTitle        string          `json:"dest_note_title"`
}

// Get all links of a specific type
func (q *Queries) GetLinksByType(ctx context.Context, linkType string) ([]GetLinksByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinksByType, linkType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksByTypeRow
	for rows.Next() {
		var i GetLinksByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.SrcNoteID,
			&i.DestNoteID,
			&i.LinkType,
			&i.Context,
			&i.CreatedByAssistantID,
			&i.Strength,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SrcNoteTitle,
			&i.DestNoteTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssistantNoteLink = `-- name: UpdateAssistantNoteLink :exec
UPDATE assistant_note_links
SET link_type = ?1,
    context = ?2,
    strength = ?3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
`

type UpdateAssistantNoteLinkParams struct {
	LinkType string          `json:"link_type"`
	Context  sql.NullString  `json:"context"`
	Strength sql.NullFloat64 `json:"strength"`
	ID       int64           `json:"id"`
}

func (q *Queries) UpdateAssistantNoteLink(ctx context.Context, arg UpdateAssistantNoteLinkParams) error {
	_, err := q.db.ExecContext(ctx, updateAssistantNoteLink,
		arg.LinkType,
		arg.Context,
		arg.Strength,
		arg.ID,
	)
	return err
}
