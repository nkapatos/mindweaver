// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package store

import (
	"context"
)

const addTagToAssistantNote = `-- name: AddTagToAssistantNote :exec

INSERT INTO assistant_note_tags (assistant_note_id, tag_id)
VALUES (?1, ?2)
ON CONFLICT DO NOTHING
`

type AddTagToAssistantNoteParams struct {
	AssistantNoteID int64 `json:"assistant_note_id"`
	TagID           int64 `json:"tag_id"`
}

// ========================================
// Tag Assignment Operations
// ========================================
func (q *Queries) AddTagToAssistantNote(ctx context.Context, arg AddTagToAssistantNoteParams) error {
	_, err := q.db.ExecContext(ctx, addTagToAssistantNote, arg.AssistantNoteID, arg.TagID)
	return err
}

const createTag = `-- name: CreateTag :execlastid

INSERT INTO tags (name, created_at, updated_at) 
VALUES (?1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
`

// tags.sql
// CRUD operations for tags table
// Tags that assistant can use to organize notes
func (q *Queries) CreateTag(ctx context.Context, name string) (int64, error) {
	result, err := q.db.ExecContext(ctx, createTag, name)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteTagByID = `-- name: DeleteTagByID :exec
DELETE FROM tags WHERE id = ?1
`

func (q *Queries) DeleteTagByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTagByID, id)
	return err
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, created_at, updated_at FROM tags WHERE id = ?1
`

func (q *Queries) GetTagByID(ctx context.Context, id int64) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, created_at, updated_at FROM tags WHERE name = ?1 LIMIT 1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAssistantNotesByTag = `-- name: ListAssistantNotesByTag :many
SELECT an.id, an.uuid, an.title, an.body, an.description, an.note_type, an.related_conversation_id, an.related_note_id, an.created_by_assistant_id, an.priority, an.due_date, an.is_completed, an.is_active, an.created_at, an.updated_at FROM assistant_notes an
JOIN assistant_note_tags ant ON an.id = ant.assistant_note_id
WHERE ant.tag_id = ?1
ORDER BY an.created_at DESC
`

func (q *Queries) ListAssistantNotesByTag(ctx context.Context, tagID int64) ([]AssistantNote, error) {
	rows, err := q.db.QueryContext(ctx, listAssistantNotesByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantNote
	for rows.Next() {
		var i AssistantNote
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.NoteType,
			&i.RelatedConversationID,
			&i.RelatedNoteID,
			&i.CreatedByAssistantID,
			&i.Priority,
			&i.DueDate,
			&i.IsCompleted,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name, created_at, updated_at FROM tags ORDER BY name
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByAssistantNote = `-- name: ListTagsByAssistantNote :many
SELECT t.id, t.name, t.created_at, t.updated_at FROM tags t
JOIN assistant_note_tags ant ON t.id = ant.tag_id
WHERE ant.assistant_note_id = ?1
ORDER BY t.name
`

func (q *Queries) ListTagsByAssistantNote(ctx context.Context, assistantNoteID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByAssistantNote, assistantNoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromAssistantNote = `-- name: RemoveTagFromAssistantNote :exec
DELETE FROM assistant_note_tags 
WHERE assistant_note_id = ?1 AND tag_id = ?2
`

type RemoveTagFromAssistantNoteParams struct {
	AssistantNoteID int64 `json:"assistant_note_id"`
	TagID           int64 `json:"tag_id"`
}

func (q *Queries) RemoveTagFromAssistantNote(ctx context.Context, arg RemoveTagFromAssistantNoteParams) error {
	_, err := q.db.ExecContext(ctx, removeTagFromAssistantNote, arg.AssistantNoteID, arg.TagID)
	return err
}
