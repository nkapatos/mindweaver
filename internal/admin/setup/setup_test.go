package setup

import (
	"log/slog"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/labstack/echo/v4"
)

func TestConfigExists(t *testing.T) {
	// Create a temp directory
	tmpDir := t.TempDir()

	// Test when config doesn't exist
	if ConfigExists(tmpDir) {
		t.Error("ConfigExists should return false when config.yaml doesn't exist")
	}

	// Create config.yaml
	configPath := filepath.Join(tmpDir, "config.yaml")
	if err := os.WriteFile(configPath, []byte("test: value"), 0o644); err != nil {
		t.Fatalf("Failed to create test config: %v", err)
	}

	// Test when config exists
	if !ConfigExists(tmpDir) {
		t.Error("ConfigExists should return true when config.yaml exists")
	}
}

func TestGenerateSecureSalt(t *testing.T) {
	salt1, err := generateSecureSalt()
	if err != nil {
		t.Fatalf("generateSecureSalt failed: %v", err)
	}

	if len(salt1) < 32 {
		t.Errorf("Salt should be at least 32 characters, got %d", len(salt1))
	}

	// Ensure salts are unique
	salt2, _ := generateSecureSalt()
	if salt1 == salt2 {
		t.Error("generateSecureSalt should produce unique salts")
	}
}

func TestGenerateConfigYAML(t *testing.T) {
	config := generateConfigYAML("/data", "localhost", 9421, "WARN", "test-salt")

	// Check that all expected fields are present
	expectedStrings := []string{
		"data_dir: /data",
		"host: localhost",
		"port: 9421",
		"level: WARN",
		"etag_salt: test-salt",
		"Generated by setup wizard",
	}

	for _, expected := range expectedStrings {
		if !strings.Contains(config, expected) {
			t.Errorf("Config should contain %q", expected)
		}
	}
}

func TestSetupRequiredMiddleware_NoConfig(t *testing.T) {
	tmpDir := t.TempDir()

	e := echo.New()
	e.Use(SetupRequiredMiddleware(tmpDir))
	e.GET("/api/test", func(c echo.Context) error {
		return c.String(http.StatusOK, "OK")
	})

	req := httptest.NewRequest(http.MethodGet, "/api/test", nil)
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusTemporaryRedirect {
		t.Errorf("Expected redirect (307), got %d", rec.Code)
	}

	location := rec.Header().Get("Location")
	if location != "/admin/setup" {
		t.Errorf("Expected redirect to /admin/setup, got %s", location)
	}
}

func TestSetupRequiredMiddleware_WithConfig(t *testing.T) {
	tmpDir := t.TempDir()

	// Create config.yaml
	configPath := filepath.Join(tmpDir, "config.yaml")
	if err := os.WriteFile(configPath, []byte("test: value"), 0o644); err != nil {
		t.Fatalf("Failed to create test config: %v", err)
	}

	e := echo.New()
	e.Use(SetupRequiredMiddleware(tmpDir))
	e.GET("/api/test", func(c echo.Context) error {
		return c.String(http.StatusOK, "OK")
	})

	req := httptest.NewRequest(http.MethodGet, "/api/test", nil)
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("Expected OK (200), got %d", rec.Code)
	}
}

func TestSetupRequiredMiddleware_HealthEndpoint(t *testing.T) {
	tmpDir := t.TempDir()
	// No config.yaml - should still allow /health

	e := echo.New()
	e.Use(SetupRequiredMiddleware(tmpDir))
	e.GET("/health", func(c echo.Context) error {
		return c.String(http.StatusOK, "healthy")
	})

	req := httptest.NewRequest(http.MethodGet, "/health", nil)
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("Health endpoint should be accessible without config, got %d", rec.Code)
	}
}

func TestSetupRequiredMiddleware_SetupEndpoint(t *testing.T) {
	tmpDir := t.TempDir()
	// No config.yaml - should still allow /admin/setup

	e := echo.New()
	e.Use(SetupRequiredMiddleware(tmpDir))
	e.GET("/admin/setup", func(c echo.Context) error {
		return c.String(http.StatusOK, "setup wizard")
	})

	req := httptest.NewRequest(http.MethodGet, "/admin/setup", nil)
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("Setup endpoint should be accessible without config, got %d", rec.Code)
	}
}

func TestHandler_GetSetup(t *testing.T) {
	tmpDir := t.TempDir()
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	handler, err := NewHandler(tmpDir, logger)
	if err != nil {
		t.Fatalf("NewHandler failed: %v", err)
	}

	e := echo.New()
	handler.RegisterRoutes(e)

	req := httptest.NewRequest(http.MethodGet, "/admin/setup", nil)
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("GET /admin/setup should return 200, got %d", rec.Code)
	}

	body := rec.Body.String()
	if !strings.Contains(body, "Mindweaver") {
		t.Error("Response should contain 'Mindweaver'")
	}
	if !strings.Contains(body, "First-time setup") {
		t.Error("Response should contain 'First-time setup'")
	}
}

func TestHandler_PostSetup(t *testing.T) {
	tmpDir := t.TempDir()
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	handler, err := NewHandler(tmpDir, logger)
	if err != nil {
		t.Fatalf("NewHandler failed: %v", err)
	}

	e := echo.New()
	handler.RegisterRoutes(e)

	// Submit setup form
	form := url.Values{}
	form.Set("allow_external", "on")
	form.Set("port", "9421")
	form.Set("log_level", "WARN")
	form.Set("etag_salt", "test-salt-123")

	req := httptest.NewRequest(http.MethodPost, "/admin/setup", strings.NewReader(form.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("POST /admin/setup should return 200, got %d", rec.Code)
	}

	// Check config file was created
	configPath := filepath.Join(tmpDir, "config.yaml")
	if _, statErr := os.Stat(configPath); os.IsNotExist(statErr) {
		t.Error("config.yaml should have been created")
	}

	// Read and verify config content
	content, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}

	configStr := string(content)
	if !strings.Contains(configStr, "host: 0.0.0.0") {
		t.Error("Config should have host: 0.0.0.0 when allow_external is on")
	}
	if !strings.Contains(configStr, "port: 9421") {
		t.Error("Config should have port: 9421")
	}
	if !strings.Contains(configStr, "level: WARN") {
		t.Error("Config should have level: WARN")
	}
	if !strings.Contains(configStr, "etag_salt: test-salt-123") {
		t.Error("Config should have the provided etag_salt")
	}

	// Check success message in response
	body := rec.Body.String()
	if !strings.Contains(body, "Setup Complete") {
		t.Error("Response should show success message")
	}
}

func TestHandler_PostSetup_InvalidPort(t *testing.T) {
	tmpDir := t.TempDir()
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	handler, err := NewHandler(tmpDir, logger)
	if err != nil {
		t.Fatalf("NewHandler failed: %v", err)
	}

	e := echo.New()
	handler.RegisterRoutes(e)

	// Submit with invalid port
	form := url.Values{}
	form.Set("port", "invalid")
	form.Set("log_level", "WARN")

	req := httptest.NewRequest(http.MethodPost, "/admin/setup", strings.NewReader(form.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusBadRequest {
		t.Errorf("POST with invalid port should return 400, got %d", rec.Code)
	}

	body := rec.Body.String()
	if !strings.Contains(body, "Invalid port") {
		t.Error("Response should show port validation error")
	}
}

func TestHandler_PostSetup_LocalhostWhenNotExternal(t *testing.T) {
	tmpDir := t.TempDir()
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelError}))

	handler, err := NewHandler(tmpDir, logger)
	if err != nil {
		t.Fatalf("NewHandler failed: %v", err)
	}

	e := echo.New()
	handler.RegisterRoutes(e)

	// Submit without allow_external
	form := url.Values{}
	form.Set("port", "9421")
	form.Set("log_level", "INFO")

	req := httptest.NewRequest(http.MethodPost, "/admin/setup", strings.NewReader(form.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	rec := httptest.NewRecorder()
	e.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("POST /admin/setup should return 200, got %d", rec.Code)
	}

	// Read config and verify localhost
	content, _ := os.ReadFile(filepath.Join(tmpDir, "config.yaml"))
	if !strings.Contains(string(content), "host: localhost") {
		t.Error("Config should have host: localhost when allow_external is off")
	}
}
