// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: collections.sql

package store

import (
	"context"
	"database/sql"
)

const checkIfSystemCollection = `-- name: CheckIfSystemCollection :one

SELECT is_system FROM collections WHERE id = ?1
`

// ========================================
// System Collection Protection
// ========================================
func (q *Queries) CheckIfSystemCollection(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfSystemCollection, id)
	var is_system bool
	err := row.Scan(&is_system)
	return is_system, err
}

const countCollections = `-- name: CountCollections :one
SELECT COUNT(*) FROM collections
`

func (q *Queries) CountCollections(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCollections)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCollectionsByParent = `-- name: CountCollectionsByParent :one
SELECT COUNT(*) FROM collections 
WHERE parent_id = ?1
`

func (q *Queries) CountCollectionsByParent(ctx context.Context, parentID interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCollectionsByParent, parentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotesInCollection = `-- name: CountNotesInCollection :one
SELECT COUNT(*) as count
FROM notes
WHERE collection_id = ?1
`

func (q *Queries) CountNotesInCollection(ctx context.Context, collectionID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotesInCollection, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCollection = `-- name: CreateCollection :execlastid

INSERT INTO collections (name, parent_id, path, description, position, is_system)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
`

type CreateCollectionParams struct {
	Name        string         `json:"name"`
	ParentID    interface{}    `json:"parent_id"`
	Path        string         `json:"path"`
	Description sql.NullString `json:"description"`
	Position    sql.NullInt64  `json:"position"`
	IsSystem    bool           `json:"is_system"`
}

// collections.sql
// CRUD operations for collections (hierarchical folders/paths for notes)
func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createCollection,
		arg.Name,
		arg.ParentID,
		arg.Path,
		arg.Description,
		arg.Position,
		arg.IsSystem,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE id = ?1
`

func (q *Queries) DeleteCollection(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCollection, id)
	return err
}

const findOrCreateCollectionByPath = `-- name: FindOrCreateCollectionByPath :one
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections WHERE path = ?1 LIMIT 1
`

// This is a helper query to find existing collection by path
// or return NULL if not found (actual creation happens in Go code)
func (q *Queries) FindOrCreateCollectionByPath(ctx context.Context, path string) (Collection, error) {
	row := q.db.QueryRowContext(ctx, findOrCreateCollectionByPath, path)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.Path,
		&i.Description,
		&i.Position,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionAncestors = `-- name: GetCollectionAncestors :many
WITH RECURSIVE ancestors AS (
  -- Start with the collection itself
  SELECT c.id, c.name, c.parent_id, c.path, 0 as depth
  FROM collections c
  WHERE c.id = ?1
  
  UNION ALL
  
  -- Recursively get parent
  SELECT c.id, c.name, c.parent_id, c.path, a.depth + 1
  FROM collections c
  JOIN ancestors a ON c.id = a.parent_id
)
SELECT id, name, parent_id, path, depth FROM ancestors WHERE depth > 0 ORDER BY depth DESC
`

type GetCollectionAncestorsRow struct {
	ID       int64       `json:"id"`
	Name     string      `json:"name"`
	ParentID interface{} `json:"parent_id"`
	Path     string      `json:"path"`
	Depth    int64       `json:"depth"`
}

// Get all ancestors of a collection by walking up the parent_id chain
func (q *Queries) GetCollectionAncestors(ctx context.Context, collectionID int64) ([]GetCollectionAncestorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionAncestors, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionAncestorsRow
	for rows.Next() {
		var i GetCollectionAncestorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionByID = `-- name: GetCollectionByID :one
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections WHERE id = ?1
`

func (q *Queries) GetCollectionByID(ctx context.Context, id int64) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollectionByID, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.Path,
		&i.Description,
		&i.Position,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionByPath = `-- name: GetCollectionByPath :one
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections WHERE path = ?1 LIMIT 1
`

func (q *Queries) GetCollectionByPath(ctx context.Context, path string) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollectionByPath, path)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.Path,
		&i.Description,
		&i.Position,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionChildren = `-- name: GetCollectionChildren :many
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections
WHERE parent_id = ?1
ORDER BY position, name
`

func (q *Queries) GetCollectionChildren(ctx context.Context, parentID interface{}) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionChildren, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Description,
			&i.Position,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionDescendants = `-- name: GetCollectionDescendants :many
WITH RECURSIVE descendants AS (
  -- Start with the collection itself
  SELECT c.id, c.name, c.parent_id, c.path, 0 as depth
  FROM collections c
  WHERE c.id = ?1
  
  UNION ALL
  
  -- Recursively get children
  SELECT c.id, c.name, c.parent_id, c.path, d.depth + 1
  FROM collections c
  JOIN descendants d ON c.parent_id = d.id
)
SELECT id, name, parent_id, path, depth FROM descendants WHERE depth > 0 ORDER BY path
`

type GetCollectionDescendantsRow struct {
	ID       int64       `json:"id"`
	Name     string      `json:"name"`
	ParentID interface{} `json:"parent_id"`
	Path     string      `json:"path"`
	Depth    int64       `json:"depth"`
}

// Get all descendants of a collection by walking down the parent_id chain
func (q *Queries) GetCollectionDescendants(ctx context.Context, collectionID int64) ([]GetCollectionDescendantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionDescendants, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionDescendantsRow
	for rows.Next() {
		var i GetCollectionDescendantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionStats = `-- name: GetCollectionStats :many
SELECT 
    c.id,
    c.name,
    c.path,
    c.parent_id,
    COUNT(n.id) as notes_count
FROM collections c
LEFT JOIN notes n ON c.id = n.collection_id
GROUP BY c.id
ORDER BY c.path
`

type GetCollectionStatsRow struct {
	ID         int64       `json:"id"`
	Name       string      `json:"name"`
	Path       string      `json:"path"`
	ParentID   interface{} `json:"parent_id"`
	NotesCount int64       `json:"notes_count"`
}

func (q *Queries) GetCollectionStats(ctx context.Context) ([]GetCollectionStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionStatsRow
	for rows.Next() {
		var i GetCollectionStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentID,
			&i.NotesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollections = `-- name: ListCollections :many
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections ORDER BY path
`

func (q *Queries) ListCollections(ctx context.Context) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Description,
			&i.Position,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollectionsByParent = `-- name: ListCollectionsByParent :many
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections 
WHERE parent_id = ?1 
ORDER BY position, name
`

func (q *Queries) ListCollectionsByParent(ctx context.Context, parentID interface{}) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollectionsByParent, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Description,
			&i.Position,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollectionsByParentPaginated = `-- name: ListCollectionsByParentPaginated :many
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections 
WHERE parent_id = ?1 
ORDER BY position, name
LIMIT ?3 OFFSET ?2
`

type ListCollectionsByParentPaginatedParams struct {
	ParentID interface{} `json:"parent_id"`
	Offset   int64       `json:"offset"`
	Limit    int64       `json:"limit"`
}

func (q *Queries) ListCollectionsByParentPaginated(ctx context.Context, arg ListCollectionsByParentPaginatedParams) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollectionsByParentPaginated, arg.ParentID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Description,
			&i.Position,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCollectionsPaginated = `-- name: ListCollectionsPaginated :many

SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections 
ORDER BY id
LIMIT ?2 OFFSET ?1
`

type ListCollectionsPaginatedParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

// ========================================
// Paginated Queries (AIP-158)
// ========================================
func (q *Queries) ListCollectionsPaginated(ctx context.Context, arg ListCollectionsPaginatedParams) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollectionsPaginated, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Description,
			&i.Position,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootCollections = `-- name: ListRootCollections :many
SELECT id, name, parent_id, path, description, position, is_system, created_at, updated_at FROM collections 
WHERE parent_id IS NULL AND id != 1
ORDER BY position, name
`

func (q *Queries) ListRootCollections(ctx context.Context) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listRootCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.Path,
			&i.Description,
			&i.Position,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollection = `-- name: UpdateCollection :exec
UPDATE collections
SET name = ?1,
    parent_id = ?2,
    path = ?3,
    description = ?4,
    position = ?5,
    is_system = ?6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?7
`

type UpdateCollectionParams struct {
	Name        string         `json:"name"`
	ParentID    interface{}    `json:"parent_id"`
	Path        string         `json:"path"`
	Description sql.NullString `json:"description"`
	Position    sql.NullInt64  `json:"position"`
	IsSystem    bool           `json:"is_system"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) error {
	_, err := q.db.ExecContext(ctx, updateCollection,
		arg.Name,
		arg.ParentID,
		arg.Path,
		arg.Description,
		arg.Position,
		arg.IsSystem,
		arg.ID,
	)
	return err
}
