// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notes_links.sql

package store

import (
	"context"
	"database/sql"
	"strings"
)

const countBrokenLinks = `-- name: CountBrokenLinks :one
SELECT COUNT(*) FROM notes_links WHERE resolved = -1
`

func (q *Queries) CountBrokenLinks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBrokenLinks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnresolvedLinks = `-- name: CountUnresolvedLinks :one
SELECT COUNT(*) FROM notes_links WHERE resolved = 0
`

func (q *Queries) CountUnresolvedLinks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnresolvedLinks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotesLink = `-- name: CreateNotesLink :execlastid
INSERT INTO notes_links (src_id, dest_id, display_text, is_embed)
VALUES (?1, ?2, ?3, ?4)
`

type CreateNotesLinkParams struct {
	SrcID       int64          `json:"src_id"`
	DestID      sql.NullInt64  `json:"dest_id"`
	DisplayText sql.NullString `json:"display_text"`
	IsEmbed     sql.NullBool   `json:"is_embed"`
}

func (q *Queries) CreateNotesLink(ctx context.Context, arg CreateNotesLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createNotesLink,
		arg.SrcID,
		arg.DestID,
		arg.DisplayText,
		arg.IsEmbed,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createUnresolvedNotesLink = `-- name: CreateUnresolvedNotesLink :execlastid
INSERT INTO notes_links (
    src_id, dest_id, dest_title, display_text, is_embed, resolved
)
VALUES (?1, NULL, ?2, ?3, ?4, 0)
`

type CreateUnresolvedNotesLinkParams struct {
	SrcID       int64          `json:"src_id"`
	DestTitle   sql.NullString `json:"dest_title"`
	DisplayText sql.NullString `json:"display_text"`
	IsEmbed     sql.NullBool   `json:"is_embed"`
}

func (q *Queries) CreateUnresolvedNotesLink(ctx context.Context, arg CreateUnresolvedNotesLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createUnresolvedNotesLink,
		arg.SrcID,
		arg.DestTitle,
		arg.DisplayText,
		arg.IsEmbed,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteNotesLinksBySrcID = `-- name: DeleteNotesLinksBySrcID :exec
DELETE FROM notes_links WHERE src_id = ?1
`

func (q *Queries) DeleteNotesLinksBySrcID(ctx context.Context, srcID int64) error {
	_, err := q.db.ExecContext(ctx, deleteNotesLinksBySrcID, srcID)
	return err
}

const findUnresolvedLinksByDestTitle = `-- name: FindUnresolvedLinksByDestTitle :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links
WHERE
    resolved = 0
    AND dest_id IS NULL
    AND dest_title = ?1
`

// Finds unresolved links that point to a specific note title
// Used when creating a note to resolve pending links
func (q *Queries) FindUnresolvedLinksByDestTitle(ctx context.Context, destTitle sql.NullString) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, findUnresolvedLinksByDestTitle, destTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotesLinkByID = `-- name: GetNotesLinkByID :one
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links WHERE id = ?1
`

func (q *Queries) GetNotesLinkByID(ctx context.Context, id int64) (NotesLink, error) {
	row := q.db.QueryRowContext(ctx, getNotesLinkByID, id)
	var i NotesLink
	err := row.Scan(
		&i.ID,
		&i.SrcID,
		&i.DestID,
		&i.DestTitle,
		&i.DisplayText,
		&i.IsEmbed,
		&i.Resolved,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNotesLinkWithNoteTitles = `-- name: GetNotesLinkWithNoteTitles :one

SELECT
    nl.id, nl.src_id, nl.dest_id, nl.dest_title, nl.display_text, nl.is_embed, nl.resolved, nl.created_at, nl.updated_at,
    src_note.title AS src_title,
    dest_note.title AS dest_title
FROM notes_links nl
JOIN notes src_note ON nl.src_id = src_note.id
JOIN notes dest_note ON nl.dest_id = dest_note.id
WHERE nl.id = ?1
`

type GetNotesLinkWithNoteTitlesRow struct {
	ID          int64          `json:"id"`
	SrcID       int64          `json:"src_id"`
	DestID      sql.NullInt64  `json:"dest_id"`
	DestTitle   sql.NullString `json:"dest_title"`
	DisplayText sql.NullString `json:"display_text"`
	IsEmbed     sql.NullBool   `json:"is_embed"`
	Resolved    sql.NullInt64  `json:"resolved"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	SrcTitle    string         `json:"src_title"`
	DestTitle_2 string         `json:"dest_title_2"`
}

// ========================================
// Composite Queries - Notes Links with Note Details
// ========================================
func (q *Queries) GetNotesLinkWithNoteTitles(ctx context.Context, id int64) (GetNotesLinkWithNoteTitlesRow, error) {
	row := q.db.QueryRowContext(ctx, getNotesLinkWithNoteTitles, id)
	var i GetNotesLinkWithNoteTitlesRow
	err := row.Scan(
		&i.ID,
		&i.SrcID,
		&i.DestID,
		&i.DestTitle,
		&i.DisplayText,
		&i.IsEmbed,
		&i.Resolved,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SrcTitle,
		&i.DestTitle_2,
	)
	return i, err
}

const listBrokenLinks = `-- name: ListBrokenLinks :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links WHERE resolved = -1 ORDER BY id
`

func (q *Queries) ListBrokenLinks(ctx context.Context) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, listBrokenLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesLinks = `-- name: ListNotesLinks :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links ORDER BY id
`

func (q *Queries) ListNotesLinks(ctx context.Context) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, listNotesLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesLinksByDestID = `-- name: ListNotesLinksByDestID :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links WHERE dest_id = ?1
`

func (q *Queries) ListNotesLinksByDestID(ctx context.Context, destID sql.NullInt64) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, listNotesLinksByDestID, destID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesLinksByNoteIDs = `-- name: ListNotesLinksByNoteIDs :many
;

SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links
WHERE src_id IN (/*SLICE:note_ids*/?)
OR dest_id IN (/*SLICE:note_ids*/?)
ORDER BY src_id, dest_id
`

// Batch query for multiple notes (graph view construction)
// Example usage: GetLinks for notes 1,2,3 to build subgraph
func (q *Queries) ListNotesLinksByNoteIDs(ctx context.Context, noteIds []int64) ([]NotesLink, error) {
	query := listNotesLinksByNoteIDs
	var queryParams []interface{}
	if len(noteIds) > 0 {
		for _, v := range noteIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:note_ids*/?", strings.Repeat(",?", len(noteIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:note_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesLinksBySrcID = `-- name: ListNotesLinksBySrcID :many

SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links WHERE src_id = ?1
`

// TODO: Add composite queries with note titles for display
func (q *Queries) ListNotesLinksBySrcID(ctx context.Context, srcID int64) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, listNotesLinksBySrcID, srcID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrphanedLinks = `-- name: ListOrphanedLinks :many

SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links
WHERE dest_id IS NULL
ORDER BY src_id, dest_title
`

// ========================================
// Additional Query Patterns (FR-LINKS-02)
// ========================================
// Returns links where destination note no longer exists (dest_id IS NULL)
// Used for "broken links" UI view (BR-03: Knowledge Preservation)
func (q *Queries) ListOrphanedLinks(ctx context.Context) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, listOrphanedLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnresolvedLinks = `-- name: ListUnresolvedLinks :many

SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links
WHERE resolved IN (0, -1)
ORDER BY id
LIMIT ?1
`

// ========================================
// WikiLink Resolution Queries
// ========================================
// Gets both pending (0) and broken (-1) links for resolution
// Broken links can become resolved if the target note is created later
func (q *Queries) ListUnresolvedLinks(ctx context.Context, limit int64) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, listUnresolvedLinks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markLinkBroken = `-- name: MarkLinkBroken :exec
UPDATE notes_links
SET resolved = -1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
`

func (q *Queries) MarkLinkBroken(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markLinkBroken, id)
	return err
}

const resolveLink = `-- name: ResolveLink :exec
UPDATE notes_links
SET dest_id = ?1,
    dest_title = NULL,
    resolved = 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
`

type ResolveLinkParams struct {
	DestID sql.NullInt64 `json:"dest_id"`
	ID     int64         `json:"id"`
}

// Resolves a pending link by setting dest_id and clearing dest_title
// dest_title is only kept for unresolved (0) and broken (-1) links
func (q *Queries) ResolveLink(ctx context.Context, arg ResolveLinkParams) error {
	_, err := q.db.ExecContext(ctx, resolveLink, arg.DestID, arg.ID)
	return err
}

const searchNotesLinksByDisplayText = `-- name: SearchNotesLinksByDisplayText :many
SELECT id, src_id, dest_id, dest_title, display_text, is_embed, resolved, created_at, updated_at FROM notes_links WHERE display_text LIKE ?1
`

func (q *Queries) SearchNotesLinksByDisplayText(ctx context.Context, displayTextPattern sql.NullString) ([]NotesLink, error) {
	rows, err := q.db.QueryContext(ctx, searchNotesLinksByDisplayText, displayTextPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotesLink
	for rows.Next() {
		var i NotesLink
		if err := rows.Scan(
			&i.ID,
			&i.SrcID,
			&i.DestID,
			&i.DestTitle,
			&i.DisplayText,
			&i.IsEmbed,
			&i.Resolved,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
