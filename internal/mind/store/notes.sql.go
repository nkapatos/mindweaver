// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notes.sql

package store

import (
	"context"
	"database/sql"
	"strings"

	"github.com/google/uuid"
)

const countNotes = `-- name: CountNotes :one
SELECT COUNT(*) FROM notes
`

func (q *Queries) CountNotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotesByCollectionID = `-- name: CountNotesByCollectionID :one
SELECT COUNT(*) FROM notes 
WHERE collection_id = ?1
`

func (q *Queries) CountNotesByCollectionID(ctx context.Context, collectionID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotesByCollectionID, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotesByIsTemplate = `-- name: CountNotesByIsTemplate :one
SELECT COUNT(*) FROM notes 
WHERE is_template = ?1
`

func (q *Queries) CountNotesByIsTemplate(ctx context.Context, isTemplate sql.NullBool) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotesByIsTemplate, isTemplate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotesByNoteTypeID = `-- name: CountNotesByNoteTypeID :one
SELECT COUNT(*) FROM notes 
WHERE note_type_id = ?1
`

func (q *Queries) CountNotesByNoteTypeID(ctx context.Context, noteTypeID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotesByNoteTypeID, noteTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNote = `-- name: CreateNote :execlastid

INSERT INTO notes (uuid, title, body, description, frontmatter, note_type_id, is_template, collection_id)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
`

type CreateNoteParams struct {
	Uuid         uuid.UUID      `json:"uuid"`
	Title        string         `json:"title"`
	Body         sql.NullString `json:"body"`
	Description  sql.NullString `json:"description"`
	Frontmatter  sql.NullString `json:"frontmatter"`
	NoteTypeID   sql.NullInt64  `json:"note_type_id"`
	IsTemplate   sql.NullBool   `json:"is_template"`
	CollectionID int64          `json:"collection_id"`
}

// notes.sql
// Pass 4: CRUD + composite queries for notes (SQLite, sqlc compatible)
// sqlc annotations added for code generation
// NOTE: uuid field uses uuidv7. Ordering by uuid. Timestamps managed by DB.
// Included: insert, select by id, select all, update by id, delete by id, composite queries
// Next: Add more composite queries for tags and FTS integration
func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createNote,
		arg.Uuid,
		arg.Title,
		arg.Body,
		arg.Description,
		arg.Frontmatter,
		arg.NoteTypeID,
		arg.IsTemplate,
		arg.CollectionID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteNoteByID = `-- name: DeleteNoteByID :exec
DELETE FROM notes WHERE id = ?1
`

func (q *Queries) DeleteNoteByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteNoteByID, id)
	return err
}

const getNoteByID = `-- name: GetNoteByID :one
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes WHERE id = ?1
`

func (q *Queries) GetNoteByID(ctx context.Context, id int64) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByID, id)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
	)
	return i, err
}

const getNoteByTitle = `-- name: GetNoteByTitle :one
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes WHERE title = ?1 AND collection_id = ?2 LIMIT 1
`

type GetNoteByTitleParams struct {
	Title        string `json:"title"`
	CollectionID int64  `json:"collection_id"`
}

func (q *Queries) GetNoteByTitle(ctx context.Context, arg GetNoteByTitleParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByTitle, arg.Title, arg.CollectionID)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
	)
	return i, err
}

const getNoteByTitleGlobal = `-- name: GetNoteByTitleGlobal :one
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes WHERE title = ?1 LIMIT 1
`

// For wikilink resolution: searches by title across all collections
// Returns first match (undefined order if multiple collections have same title)
func (q *Queries) GetNoteByTitleGlobal(ctx context.Context, title string) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByTitleGlobal, title)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
	)
	return i, err
}

const getNoteByTitleInCollection = `-- name: GetNoteByTitleInCollection :one
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
WHERE title = ?1 AND collection_id = ?2 
LIMIT 1
`

type GetNoteByTitleInCollectionParams struct {
	Title        string `json:"title"`
	CollectionID int64  `json:"collection_id"`
}

// Lookup note by title within a specific collection (titles unique per collection)
func (q *Queries) GetNoteByTitleInCollection(ctx context.Context, arg GetNoteByTitleInCollectionParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByTitleInCollection, arg.Title, arg.CollectionID)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
	)
	return i, err
}

const getNoteByUUID = `-- name: GetNoteByUUID :one
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes WHERE uuid = ?1
`

func (q *Queries) GetNoteByUUID(ctx context.Context, argUuid uuid.UUID) (Note, error) {
	row := q.db.QueryRowContext(ctx, getNoteByUUID, argUuid)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
	)
	return i, err
}

const getNoteWithAllRelationsByID = `-- name: GetNoteWithAllRelationsByID :one

SELECT 
    n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template,
    nt.id as type_id,
    nt.type as type_type,
    nt.name as type_name,
    nt.description as type_description,
    nt.icon as type_icon,
    nt.color as type_color,
    -- Meta as JSON object (SQLite specific)
    (
        SELECT GROUP_CONCAT('"' || nm.key || '":' || json_quote(nm.value), ',')
        FROM note_meta nm WHERE nm.note_id = n.id
    ) as meta_json,
    -- Tags as JSON array
    (
        SELECT GROUP_CONCAT(json_quote(t.name), ',')
        FROM tags t
        JOIN note_tags ntg ON t.id = ntg.tag_id
        WHERE ntg.note_id = n.id
    ) as tags_json
FROM notes n
LEFT JOIN note_types nt ON n.note_type_id = nt.id
WHERE n.id = ?1
`

type GetNoteWithAllRelationsByIDRow struct {
	ID              int64          `json:"id"`
	Uuid            uuid.UUID      `json:"uuid"`
	Title           string         `json:"title"`
	Body            sql.NullString `json:"body"`
	Description     sql.NullString `json:"description"`
	Frontmatter     sql.NullString `json:"frontmatter"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	Version         int64          `json:"version"`
	NoteTypeID      sql.NullInt64  `json:"note_type_id"`
	CollectionID    int64          `json:"collection_id"`
	IsTemplate      sql.NullBool   `json:"is_template"`
	TypeID          sql.NullInt64  `json:"type_id"`
	TypeType        sql.NullString `json:"type_type"`
	TypeName        sql.NullString `json:"type_name"`
	TypeDescription sql.NullString `json:"type_description"`
	TypeIcon        sql.NullString `json:"type_icon"`
	TypeColor       sql.NullString `json:"type_color"`
	MetaJson        string         `json:"meta_json"`
	TagsJson        string         `json:"tags_json"`
}

// ========================================
// Composite Query - Note with All Relations
// ========================================
func (q *Queries) GetNoteWithAllRelationsByID(ctx context.Context, id int64) (GetNoteWithAllRelationsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNoteWithAllRelationsByID, id)
	var i GetNoteWithAllRelationsByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
		&i.TypeID,
		&i.TypeType,
		&i.TypeName,
		&i.TypeDescription,
		&i.TypeIcon,
		&i.TypeColor,
		&i.MetaJson,
		&i.TagsJson,
	)
	return i, err
}

const getNoteWithMetaByID = `-- name: GetNoteWithMetaByID :one

SELECT 
    n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template,
    GROUP_CONCAT(nm.key || ':' || nm.value, '|') as meta_pairs
FROM notes n
LEFT JOIN note_meta nm ON n.id = nm.note_id
WHERE n.id = ?1
GROUP BY n.id
`

type GetNoteWithMetaByIDRow struct {
	ID           int64          `json:"id"`
	Uuid         uuid.UUID      `json:"uuid"`
	Title        string         `json:"title"`
	Body         sql.NullString `json:"body"`
	Description  sql.NullString `json:"description"`
	Frontmatter  sql.NullString `json:"frontmatter"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	Version      int64          `json:"version"`
	NoteTypeID   sql.NullInt64  `json:"note_type_id"`
	CollectionID int64          `json:"collection_id"`
	IsTemplate   sql.NullBool   `json:"is_template"`
	MetaPairs    string         `json:"meta_pairs"`
}

// ========================================
// Composite Queries - Notes with Relations
// ========================================
func (q *Queries) GetNoteWithMetaByID(ctx context.Context, id int64) (GetNoteWithMetaByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNoteWithMetaByID, id)
	var i GetNoteWithMetaByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
		&i.MetaPairs,
	)
	return i, err
}

const getNoteWithTypeByID = `-- name: GetNoteWithTypeByID :one
SELECT 
    n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template,
    nt.id as type_id,
    nt.type as type_type,
    nt.name as type_name,
    nt.description as type_description,
    nt.icon as type_icon,
    nt.color as type_color
FROM notes n
LEFT JOIN note_types nt ON n.note_type_id = nt.id
WHERE n.id = ?1
`

type GetNoteWithTypeByIDRow struct {
	ID              int64          `json:"id"`
	Uuid            uuid.UUID      `json:"uuid"`
	Title           string         `json:"title"`
	Body            sql.NullString `json:"body"`
	Description     sql.NullString `json:"description"`
	Frontmatter     sql.NullString `json:"frontmatter"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	Version         int64          `json:"version"`
	NoteTypeID      sql.NullInt64  `json:"note_type_id"`
	CollectionID    int64          `json:"collection_id"`
	IsTemplate      sql.NullBool   `json:"is_template"`
	TypeID          sql.NullInt64  `json:"type_id"`
	TypeType        sql.NullString `json:"type_type"`
	TypeName        sql.NullString `json:"type_name"`
	TypeDescription sql.NullString `json:"type_description"`
	TypeIcon        sql.NullString `json:"type_icon"`
	TypeColor       sql.NullString `json:"type_color"`
}

func (q *Queries) GetNoteWithTypeByID(ctx context.Context, id int64) (GetNoteWithTypeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getNoteWithTypeByID, id)
	var i GetNoteWithTypeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Title,
		&i.Body,
		&i.Description,
		&i.Frontmatter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.NoteTypeID,
		&i.CollectionID,
		&i.IsTemplate,
		&i.TypeID,
		&i.TypeType,
		&i.TypeName,
		&i.TypeDescription,
		&i.TypeIcon,
		&i.TypeColor,
	)
	return i, err
}

const listNotes = `-- name: ListNotes :many
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes ORDER BY uuid
`

func (q *Queries) ListNotes(ctx context.Context) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByCollectionID = `-- name: ListNotesByCollectionID :many

SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
WHERE collection_id = ?1
ORDER BY title
`

// ========================================
// Collection Queries
// ========================================
func (q *Queries) ListNotesByCollectionID(ctx context.Context, collectionID int64) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByCollectionID, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByCollectionIDPaginated = `-- name: ListNotesByCollectionIDPaginated :many
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
WHERE collection_id = ?1
ORDER BY id
LIMIT ?3 OFFSET ?2
`

type ListNotesByCollectionIDPaginatedParams struct {
	CollectionID int64 `json:"collection_id"`
	Offset       int64 `json:"offset"`
	Limit        int64 `json:"limit"`
}

func (q *Queries) ListNotesByCollectionIDPaginated(ctx context.Context, arg ListNotesByCollectionIDPaginatedParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByCollectionIDPaginated, arg.CollectionID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByCollectionPath = `-- name: ListNotesByCollectionPath :many
SELECT n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template FROM notes n
INNER JOIN collections c ON n.collection_id = c.id
WHERE c.path = ?1
ORDER BY n.title
`

func (q *Queries) ListNotesByCollectionPath(ctx context.Context, path string) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByCollectionPath, path)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByIsTemplatePaginated = `-- name: ListNotesByIsTemplatePaginated :many
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
WHERE is_template = ?1
ORDER BY id
LIMIT ?3 OFFSET ?2
`

type ListNotesByIsTemplatePaginatedParams struct {
	IsTemplate sql.NullBool `json:"is_template"`
	Offset     int64        `json:"offset"`
	Limit      int64        `json:"limit"`
}

func (q *Queries) ListNotesByIsTemplatePaginated(ctx context.Context, arg ListNotesByIsTemplatePaginatedParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByIsTemplatePaginated, arg.IsTemplate, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByMetaKeys = `-- name: ListNotesByMetaKeys :many
SELECT DISTINCT n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template FROM notes n
JOIN note_meta nm ON n.id = nm.note_id
WHERE nm.key = ?1
ORDER BY n.uuid
`

func (q *Queries) ListNotesByMetaKeys(ctx context.Context, key string) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByMetaKeys, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByNoteTypeID = `-- name: ListNotesByNoteTypeID :many
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
WHERE note_type_id = ?1
ORDER BY updated_at DESC
`

func (q *Queries) ListNotesByNoteTypeID(ctx context.Context, noteTypeID sql.NullInt64) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByNoteTypeID, noteTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByNoteTypeIDPaginated = `-- name: ListNotesByNoteTypeIDPaginated :many
SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
WHERE note_type_id = ?1
ORDER BY id
LIMIT ?3 OFFSET ?2
`

type ListNotesByNoteTypeIDPaginatedParams struct {
	NoteTypeID sql.NullInt64 `json:"note_type_id"`
	Offset     int64         `json:"offset"`
	Limit      int64         `json:"limit"`
}

func (q *Queries) ListNotesByNoteTypeIDPaginated(ctx context.Context, arg ListNotesByNoteTypeIDPaginatedParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByNoteTypeIDPaginated, arg.NoteTypeID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByTagIDs = `-- name: ListNotesByTagIDs :many

SELECT DISTINCT n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template FROM notes n
JOIN note_tags nt ON n.id = nt.note_id
WHERE nt.tag_id = ?1
ORDER BY n.uuid
`

// ========================================
// Filter Queries - Notes by Relations
// ========================================
func (q *Queries) ListNotesByTagIDs(ctx context.Context, tagID int64) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesByTagIDs, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByTagIDsAND = `-- name: ListNotesByTagIDsAND :many

SELECT n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template FROM notes n
JOIN note_tags nt ON n.id = nt.note_id
WHERE nt.tag_id IN (/*SLICE:tag_ids*/?)
GROUP BY n.id
HAVING COUNT(DISTINCT nt.tag_id) = ?2
ORDER BY n.uuid
`

type ListNotesByTagIDsANDParams struct {
	TagIds   []int64 `json:"tag_ids"`
	TagCount int64   `json:"tag_count"`
}

// ========================================
// Multi-Tag Filtering (FR-TAGS-02)
// ========================================
// Returns notes that have ALL specified tags (intersection)
// Example: tag_ids = [1,2,3] returns notes tagged with 1 AND 2 AND 3
// Implementation: COUNT(DISTINCT tag_id) must equal number of requested tags
func (q *Queries) ListNotesByTagIDsAND(ctx context.Context, arg ListNotesByTagIDsANDParams) ([]Note, error) {
	query := listNotesByTagIDsAND
	var queryParams []interface{}
	if len(arg.TagIds) > 0 {
		for _, v := range arg.TagIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tag_ids*/?", strings.Repeat(",?", len(arg.TagIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tag_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.TagCount)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByTagIDsOR = `-- name: ListNotesByTagIDsOR :many
SELECT DISTINCT n.id, n.uuid, n.title, n.body, n.description, n.frontmatter, n.created_at, n.updated_at, n.version, n.note_type_id, n.collection_id, n.is_template FROM notes n
JOIN note_tags nt ON n.id = nt.note_id
WHERE nt.tag_id IN (/*SLICE:tag_ids*/?)
ORDER BY n.uuid
`

// Returns notes that have ANY of the specified tags (union)
// Example: tag_ids = [1,2,3] returns notes tagged with 1 OR 2 OR 3
func (q *Queries) ListNotesByTagIDsOR(ctx context.Context, tagIds []int64) ([]Note, error) {
	query := listNotesByTagIDsOR
	var queryParams []interface{}
	if len(tagIds) > 0 {
		for _, v := range tagIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tag_ids*/?", strings.Repeat(",?", len(tagIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tag_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesPaginated = `-- name: ListNotesPaginated :many

SELECT id, uuid, title, body, description, frontmatter, created_at, updated_at, version, note_type_id, collection_id, is_template FROM notes 
ORDER BY id
LIMIT ?2 OFFSET ?1
`

type ListNotesPaginatedParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

// ========================================
// Paginated Queries (AIP-158)
// ========================================
func (q *Queries) ListNotesPaginated(ctx context.Context, arg ListNotesPaginatedParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, listNotesPaginated, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Title,
			&i.Body,
			&i.Description,
			&i.Frontmatter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.NoteTypeID,
			&i.CollectionID,
			&i.IsTemplate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNoteByID = `-- name: UpdateNoteByID :exec
UPDATE notes
SET uuid = ?1,
    title = ?2,
    body = ?3,
    description = ?4,
    frontmatter = ?5,
    updated_at = CURRENT_TIMESTAMP,
    note_type_id = ?6,
    is_template = ?7,
    collection_id = ?8,
    version = version + 1
WHERE id = ?9 and version = ?10
`

type UpdateNoteByIDParams struct {
	Uuid         uuid.UUID      `json:"uuid"`
	Title        string         `json:"title"`
	Body         sql.NullString `json:"body"`
	Description  sql.NullString `json:"description"`
	Frontmatter  sql.NullString `json:"frontmatter"`
	NoteTypeID   sql.NullInt64  `json:"note_type_id"`
	IsTemplate   sql.NullBool   `json:"is_template"`
	CollectionID int64          `json:"collection_id"`
	ID           int64          `json:"id"`
	Version      int64          `json:"version"`
}

func (q *Queries) UpdateNoteByID(ctx context.Context, arg UpdateNoteByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateNoteByID,
		arg.Uuid,
		arg.Title,
		arg.Body,
		arg.Description,
		arg.Frontmatter,
		arg.NoteTypeID,
		arg.IsTemplate,
		arg.CollectionID,
		arg.ID,
		arg.Version,
	)
	return err
}
